javascript:(() => { const VERSION = '2025.11.29'; const AUTH_CODE = '1119'; 'use strict'; if (window.__followBot) { alert('Already running'); return; } window.__followBot = true; class FeatureConfig { constructor(name, options = {}) { this.featureName = name; this.allowFollowing = options.allowFollowing ?? true; this.allowSurfing = options.allowSurfing ?? true; this.allowScrolling = options.allowScrolling ?? true; this.allowDynamicLoading = options.allowDynamicLoading ?? true; this.customDelay = options.customDelay ?? null; this.maxOperations = options.maxOperations ?? null; this.onlyClipIdMatching = options.onlyClipIdMatching ?? false; this.scrollToTopAfterAction = options.scrollToTopAfterAction ?? true; this.requirements = options.requirements ?? []; this.restrictions = options.restrictions ?? []; } isAllowed(action) { const actionMap = { 'follow': this.allowFollowing, 'surf': this.allowSurfing, 'scroll': this.allowScrolling, 'dynamicLoad': this.allowDynamicLoading }; return actionMap[action] ?? false; } checkRestrictions(context) { return this.restrictions.every(restriction => { if (typeof restriction === 'function') { return restriction(context); } return true; }); } checkRequirements(context) { return this.requirements.every(requirement => { if (typeof requirement === 'function') { return requirement(context); } return true; }); } } class APITimingConfig { static PRESETS = { slow: { name: 'ëŠë¦¼ (ì•ˆì „)', description: 'ë„¤íŠ¸ì›Œí¬ê°€ ëŠë¦¬ê±°ë‚˜ ì•ˆì •ì„±ì´ ì¤‘ìš”í•œ ê²½ìš°', baseDelay: 2500, jitterRange: 400, surfWaitTime: 3000, tabSwitchDelay: 1500, scrollDelay: 2500, mainLoopInterval: 1500, apiCallDelay: 1000, }, normal: { name: 'ë³´í†µ (ê¶Œì¥)', description: 'ì¼ë°˜ì ì¸ í™˜ê²½ì—ì„œ ì•ˆì •ì ì¸ ì†ë„', baseDelay: 2000, jitterRange: 300, surfWaitTime: 2000, tabSwitchDelay: 1000, scrollDelay: 2000, mainLoopInterval: 1000, apiCallDelay: 800, }, fast: { name: 'ë¹ ë¦„ (ì£¼ì˜)', description: 'ë„¤íŠ¸ì›Œí¬ê°€ ë¹ ë¥¸ í™˜ê²½ (ë°´ ìœ„í—˜ ì¦ê°€)', baseDelay: 1500, jitterRange: 200, surfWaitTime: 1500, tabSwitchDelay: 800, scrollDelay: 1500, mainLoopInterval: 800, apiCallDelay: 600, } }; static current = null; static applyPreset(presetName) { if (!this.PRESETS[presetName]) { console.error('Unknown preset:', presetName); presetName = 'normal'; } this.current = this.PRESETS[presetName]; console.log(`âš¡ API íƒ€ì´ë° í”„ë¦¬ì…‹ ì ìš©: ${this.current.name}`); } static getRandomDelay() { if (!this.current) this.applyPreset('normal'); const jitter = (Math.random() - 0.5) * 2 * this.current.jitterRange; return Math.max(200, this.current.baseDelay + jitter); } static get(key) { if (!this.current) this.applyPreset('normal'); return this.current[key] || 1000; } } APITimingConfig.applyPreset('normal'); class FollowSurfConfig extends FeatureConfig { constructor() { super('FollowSurf', { allowFollowing: true, allowSurfing: true, allowScrolling: false, allowDynamicLoading: false, maxOperations: 1000, requirements: [ (context) => context.state.totalSurf < 1000 ] }); } } class ExcelExportConfig extends FeatureConfig { constructor() { super('ExcelExport', { allowFollowing: false, allowSurfing: false, allowScrolling: true, allowDynamicLoading: true, onlyClipIdMatching: true, scrollToTopAfterAction: false, requirements: [ (context) => window.location.href.includes('clip.naver.com/@') ] }); } } class UnfollowCleanConfig extends FeatureConfig { constructor() { super('UnfollowClean', { allowFollowing: false, allowSurfing: false, allowScrolling: true, allowDynamicLoading: true, onlyClipIdMatching: true, scrollToTopAfterAction: false, customDelay: 1200, restrictions: [ (context) => !context.state.followingProcessing ] }); } } class FeatureContext { constructor(config) { this.config = config; this.state = this.createFeatureState(); this.isActive = false; } createFeatureState() { const baseState = { run: true, delay: this.config.customDelay || APITimingConfig.getRandomDelay(), scrollDelay: APITimingConfig.get('scrollDelay'), currentPage: 'unknown', lastScrollY: 0, stableScrollCount: 0 }; switch (this.config.featureName) { case 'FollowSurf': return { ...baseState, empty: 0, totalFollow: 0, totalSurf: 0, clickedButtons: new Set(), followedAccounts: new Set(), dynamicLoads: 0, justSurfed: false, followingProcessing: false }; case 'ExcelExport': return { ...baseState, collectedData: { followers: [], following: [] }, collectionProgress: 0, totalToCollect: 0, isCollecting: false }; case 'UnfollowClean': return { ...baseState, followersMap: new Map(), unfollowCount: 0, processedButtons: new Set(), totalProcessed: 0, isProcessing: false }; default: return baseState; } } canPerform(action) { return this.isActive && this.config.isAllowed(action) && this.config.checkRequirements(this) && this.config.checkRestrictions(this); } activate() { this.isActive = true; console.log(`[${this.config.featureName}] ê¸°ëŠ¥ í™œì„±í™”ë¨`); } deactivate() { this.isActive = false; console.log(`[${this.config.featureName}] ê¸°ëŠ¥ ë¹„í™œì„±í™”ë¨`); } reset() { const oldState = this.state; this.state = this.createFeatureState(); this.state.run = oldState.run; console.log(`[${this.config.featureName}] ìƒíƒœ ì´ˆê¸°í™”ë¨`); } } class BotState { constructor(context = null) { this.context = context; } get run() { return this.context?.state.run ?? true; } set run(value) { if (this.context) this.context.state.run = value; } get delay() { return APITimingConfig.getRandomDelay(); } get scrollDelay() { return this.context?.state.scrollDelay ?? APITimingConfig.get('scrollDelay'); } get empty() { return this.context?.state.empty ?? 0; } set empty(value) { if (this.context) this.context.state.empty = value; } get totalFollow() { return this.context?.state.totalFollow ?? 0; } set totalFollow(value) { if (this.context) this.context.state.totalFollow = value; } get totalSurf() { return this.context?.state.totalSurf ?? 0; } set totalSurf(value) { if (this.context) this.context.state.totalSurf = value; } get clickedButtons() { return this.context?.state.clickedButtons ?? new Set(); } get followedAccounts() { return this.context?.state.followedAccounts ?? new Set(); } get currentPage() { return this.context?.state.currentPage ?? 'unknown'; } set currentPage(value) { if (this.context) this.context.state.currentPage = value; } get lastScrollY() { return this.context?.state.lastScrollY ?? 0; } set lastScrollY(value) { if (this.context) this.context.state.lastScrollY = value; } get stableScrollCount() { return this.context?.state.stableScrollCount ?? 0; } set stableScrollCount(value) { if (this.context) this.context.state.stableScrollCount = value; } get dynamicLoads() { return this.context?.state.dynamicLoads ?? 0; } set dynamicLoads(value) { if (this.context) this.context.state.dynamicLoads = value; } get justSurfed() { return this.context?.state.justSurfed ?? false; } set justSurfed(value) { if (this.context) this.context.state.justSurfed = value; } setContext(context) { this.context = context; } reset() { if (this.context) { this.context.reset(); } } setJustSurfed() { if (this.context && this.context.state.justSurfed !== undefined) { this.context.state.justSurfed = true; setTimeout(() => { if (this.context) { this.context.state.justSurfed = false; } }, 5000); } } } class Utils { static queryAll(selector, searchArea = document) { return Array.from(searchArea.querySelectorAll(selector)); } static normalizeText(element) { return (element.textContent || '').replace(/\s+/g, '').trim(); } static isVisible(element) { const rect = element.getBoundingClientRect(); return rect.bottom >= -800 && rect.top <= innerHeight + 800; } static sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } static scrollToCenter(element) { element.scrollIntoView({ block: 'center', behavior: 'smooth' }); } static simulateMouseEvents(element) { const events = ['mouseover', 'mousedown', 'mouseup']; events.forEach(eventType => { element.dispatchEvent(new MouseEvent(eventType, { bubbles: true })); }); } static getFixedUIStyles() { return ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: rgba(14,14,16,.88); backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,.35); font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; } static getServiceHeaderHTML() { return ` <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.16); padding-bottom: 6px; font-size: 12px; font-weight: 600; text-align: center;"> ë¸”ë¡œê·¸ ì •ë³´ í† ë¡ ë°©: <a href="https://open.kakao.com/o/gZmiqNDh" target="_blank" rel="noopener" style="color: #9ccfff; text-decoration: underline;">ë“¤ì–´ê°€ê¸°</a> </div> `; } static addHoverEffects(button) { button.onmouseenter = () => button.style.filter = 'brightness(1.06)'; button.onmouseleave = () => button.style.filter = 'none'; button.onmousedown = () => button.style.transform = 'scale(0.98)'; button.onmouseup = () => button.style.transform = 'scale(1)'; } static extractProfileId() { try { const html = document.documentElement.innerHTML; const matches = [...html.matchAll(/"profileId":"([A-Za-z0-9_\-]+)"/g)].map(x => x[1]); if (matches.length) { const frequency = matches.reduce((acc, val) => (acc[val] = (acc[val] || 0) + 1, acc), {}); return Object.entries(frequency).sort((a, b) => b[1] - a[1])[0][0]; } } catch (error) { console.warn('Profile ID extraction error:', error); } return null; } static async getProfileIdFromClipId(clipId) { try { const query = `query userProfileQuery($input:UserInput!){user(input:$input){id profileId clipId nickname}}`; const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'content-type': 'application/json' }, body: JSON.stringify({ query: query, variables: { input: { clipId: clipId } } }) }); const result = await response.json(); const profileId = result.data?.user?.profileId; if (profileId) { console.log(`[getProfileIdFromClipId] clipId(${clipId}) -> profileId(${profileId})`); return profileId; } } catch (error) { console.error('getProfileIdFromClipId error:', error); } return null; } static updateStatus(ui, message) { if (ui) { const statusText = ui.querySelector('#statusText'); if (statusText) { statusText.textContent = message; } else { ui.textContent = message; } } } static cleanup(ui, message = null, delay = 1000) { if (message) { this.updateStatus(ui, message); } const doCleanup = () => { if (ui) { ui.remove(); } }; if (delay > 0) { setTimeout(doCleanup, delay); } else { doCleanup(); } } static setupCancelButton(button, instance) { button.onclick = () => { instance.cancelled = true; instance.updateStatus('âŒ ì‚¬ìš©ìê°€ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤'); setTimeout(() => instance.cleanup(), 1000); }; } static async fetchFollowData(profileId, type, statusCallback, cancelCallback, maxCount = null) { const endpoint = '/api/graphql'; const queries = { followers: `query userFollowersInfinitePaginationQuery($after:String,$first:Int,$input:FollowersInput!,$nextCursor:String){...userFollowersPaginationRefetchableFragment_2lRZMj}fragment userFollowersPaginationRefetchableFragment_2lRZMj on Query{followers(input:$input,after:$after,first:$first,nextCursor:$nextCursor){edges{cursor node{profileId nickname...userUsersPaginationItem id __typename}}pageInfo{hasNextPage totalCount endCursor}nextCursor}}fragment userUsersPaginationItem on User{id profileId clipId nickname profileImageUrl description follow}`, followings: `query userFollowingsInfinitePaginationQuery($after:String,$first:Int,$input:FollowingsInput!,$nextCursor:String){...userFollowingsPaginationRefetchableFragment_2lRZMj}fragment userFollowingsPaginationRefetchableFragment_2lRZMj on Query{followings(input:$input,after:$after,first:$first,nextCursor:$nextCursor){edges{cursor node{profileId nickname...userUsersPaginationItem id __typename}}pageInfo{hasNextPage totalCount endCursor}nextCursor}}fragment userUsersPaginationItem on User{id profileId clipId nickname profileImageUrl description follow}` }; const query = queries[type]; const key = type; let cursor = null; let nextCursor = null; const results = []; for (let i = 0; i < 9999; i++) { if (cancelCallback && cancelCallback()) break; if (maxCount && results.length >= maxCount) { console.log(`[fetchFollowData] ìµœëŒ€ ê°œìˆ˜(${maxCount})ì— ë„ë‹¬í•˜ì—¬ ìˆ˜ì§‘ ì¤‘ë‹¨`); break; } if (statusCallback) { const limitText = maxCount ? ` (ìµœëŒ€ ${maxCount}ëª…)` : ''; statusCallback(`ğŸ“¥ ${type} ${results.length}ê°œ ìˆ˜ì§‘ ì¤‘...${limitText}`); } const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 20, input: { profileId: profileId }, nextCursor: nextCursor } }) }); const data = await response.json(); const root = data.data[key]; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) { continue; } results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); if (maxCount && results.length >= maxCount) { console.log(`[fetchFollowData] ìµœëŒ€ ê°œìˆ˜(${maxCount})ì— ë„ë‹¬`); break; } } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; nextCursor = root.nextCursor; await Utils.sleep(APITimingConfig.get('apiCallDelay') + Math.random() * 250); } return results; } static async followViaGraphQL(profileId, clipId) { try { const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7', 'content-type': 'application/json', 'Referer': `https://clip.naver.com/@${clipId}/follow?tab=following` }, body: JSON.stringify({ query: `mutation userFollowUserMutation($input:FollowUserInput!){followUser(input:$input){__typename...on FollowUserSucceed{success}...on CommonError{message code}}}`, variables: { input: { profileId: profileId } } }) }); const result = await response.json(); return result.data?.followUser?.__typename === 'FollowUserSucceed'; } catch (error) { console.error('Follow GraphQL error:', error); return false; } } static async unfollowViaGraphQL(profileId, clipId) { try { const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7', 'content-type': 'application/json', 'Referer': `https://clip.naver.com/@${clipId}/follow?tab=following` }, body: JSON.stringify({ query: `mutation userUnfollowUserMutation($input:UnfollowUserInput!){unfollowUser(input:$input){__typename...on UnfollowUserSucceed{success}...on CommonError{message code}}}`, variables: { input: { profileId: profileId } } }) }); const result = await response.json(); return result.data?.unfollowUser?.__typename === 'UnfollowUserSucceed'; } catch (error) { console.error('Unfollow GraphQL error:', error); return false; } } static createProgressUI(title, badgeText, badgeColor, onPause, onClose) { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">${title}</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: ${badgeColor}; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">${badgeText}</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px; text-align: center;"> ì§„í–‰: <b id="processedCount">0</b> / <b id="totalCount">0</b> | ì„±ê³µ: <b id="successCount">0</b> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">ì¤€ë¹„ ì¤‘...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> ë²„ì „ : ${VERSION} </div> `; document.body.appendChild(ui); Utils.setupProgressButtons(ui, onPause, onClose); return ui; } static setupProgressButtons(ui, onPause, onClose) { const pauseBtn = ui.querySelector('#pauseBtn'); const closeBtn = ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (onPause) onPause(); }); closeBtn.addEventListener('click', () => { if (onClose) onClose(); }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); } } class UIConstants { static COLORS = { red: '#ef4444', redDim: '#b91c1c', blue: '#3b82f6', green: '#10b981', orange: '#f59e0b', bg: 'rgba(14,14,16,.88)', cardShadow: '0 8px 30px rgba(0,0,0,.35)' }; static LABELS = { follow: 'íŒ”ë¡œìš°', surf: 'íŒŒë„íƒ€ê¸°', paused: 'ì¼ì‹œì •ì§€', done: '1000íšŒ ì™„ë£Œ' }; } class BotUI { constructor(state) { this.state = state; this.elements = {}; this.createUI(); this.bindEvents(); } createUI() { const ui = document.createElement('div'); ui.style.cssText = this.getMainUIStyles(); ui.innerHTML = this.getUITemplate(); document.body.appendChild(ui); this.ui = ui; this.cacheElements(); this.setupButtons(); } getMainUIStyles() { return ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: ${UIConstants.COLORS.bg}; backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: ${UIConstants.COLORS.cardShadow}; font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; } getUITemplate() { return ` ${Utils.getServiceHeaderHTML()} <div style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:4px"> <b style="font-size:13px">Clip Follow Surfer</b> <span id="badge" style="padding:2px 8px;border-radius:999px;background:#10b981;color:#052;font-weight:700;font-size:10px;letter-spacing:.25px"> ì„œí•‘ì¤‘ </span> </div> <div id="stats" style="opacity:.95;font-size:11px;line-height:1.4"> íŒ”ë¡œìš°: <b id="followCount">0</b>ëª… | íŒŒë„íƒ€ê¸°: <b id="surfCount">0</b>/1000íšŒ </div> <div id="currentAction" style="opacity:.8;font-size:10px;color:#9ccfff;margin:4px 0;min-height:15px;display:flex;align-items:center;justify-content:center"> íƒì§€ì¤‘... </div> <div style="margin-top:8px;margin-bottom:4px"> <div style="font-size:10px;opacity:.7;margin-bottom:4px;text-align:center"> âš¡ API ì†ë„: <span id="currentSpeedLabel" style="color:#10b981;font-weight:700">ë³´í†µ</span> </div> <div id="speedButtons" style="display:flex;gap:4px;justify-content:center"> <button data-speed="slow" style="flex:1;padding:4px 8px;border:0;border-radius:6px;font-size:10px;font-weight:600;cursor:pointer;background:#4b5563;color:#fff;transition:all .15s ease;opacity:0.7"> ëŠë¦¼ </button> <button data-speed="normal" style="flex:1;padding:4px 8px;border:0;border-radius:6px;font-size:10px;font-weight:600;cursor:pointer;background:#10b981;color:#052;transition:all .15s ease;box-shadow:0 0 0 2px rgba(16,185,129,0.3)"> ë³´í†µ </button> <button data-speed="fast" style="flex:1;padding:4px 8px;border:0;border-radius:6px;font-size:10px;font-weight:600;cursor:pointer;background:#4b5563;color:#fff;transition:all .15s ease;opacity:0.7"> ë¹ ë¦„ </button> </div> <div style="font-size:9px;opacity:.6;margin-top:2px;text-align:center;line-height:1.3"> ğŸ’¡ ë„¤íŠ¸ì›Œí¬ ëŠë¦¬ê±°ë‚˜ ë°´ ê±±ì •ë˜ë©´ 'ëŠë¦¼' ì„ íƒ </div> </div> <div style="margin-top:8px;margin-bottom:4px"> <div style="font-size:10px;opacity:.7;margin-bottom:4px;text-align:center"> ğŸ” ê³„ì • ë‹¹ íŒ”ë¡œì›Œ ìµœëŒ€ íƒì§€ ìˆ˜ </div> <div style="display:flex;align-items:center;justify-content:center;gap:6px"> <input id="maxFollowersInput" type="number" min="100" max="10000" step="100" value="100" style="width:80px;padding:4px 8px;border:1px solid rgba(255,255,255,0.2);border-radius:6px;background:rgba(255,255,255,0.1);color:#fff;font-size:11px;text-align:center;font-weight:600"> <span style="font-size:10px;opacity:.7">ëª…</span> </div> <div style="font-size:9px;opacity:.6;margin-top:2px;text-align:center;line-height:1.3"> ğŸ’¡ ìµœê·¼ íŒ”ë¡œì›Œë§Œ íƒì§€ (ì˜¤ë˜ëœ íŒ”ë¡œì›Œ ì œì™¸) </div> </div> <div id="btnRow" style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;justify-content:center"> <button id="pauseBtn" style="flex:1 1 auto;width:80%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease"> Stop </button> <button id="closeBtn" style="flex:1 1 auto;width:38%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease;display:none"> Close </button> </div> <div style="margin-top:10px;border-top:1px solid rgba(255,255,255,.16);padding-top:8px;font-size:10px;opacity:.7"> ë²„ì „ : ${VERSION} </div> `; } cacheElements() { this.elements = { stats: this.ui.querySelector('#stats'), pauseBtn: this.ui.querySelector('#pauseBtn'), closeBtn: this.ui.querySelector('#closeBtn'), badge: this.ui.querySelector('#badge'), action: this.ui.querySelector('#currentAction'), followCount: this.ui.querySelector('#followCount'), surfCount: this.ui.querySelector('#surfCount') }; } setupButtons() { this.addHoverEffects(this.elements.pauseBtn); this.addHoverEffects(this.elements.closeBtn); this.setRunningState(); } addHoverEffects(button) { Utils.addHoverEffects(button); } setButtonColor(button, backgroundColor) { button.style.background = backgroundColor; button.style.color = '#fff'; } setRunningState() { this.state.run = true; this.elements.pauseBtn.textContent = 'Stop'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.red); this.elements.pauseBtn.style.width = '80%'; this.elements.closeBtn.style.display = 'none'; this.elements.badge.textContent = 'ì„œí•‘ì¤‘'; this.elements.badge.style.background = UIConstants.COLORS.green; this.updateAction('ë™ì‘ì¤‘...'); } setPausedState(reason = UIConstants.LABELS.paused) { this.state.run = false; this.elements.pauseBtn.textContent = 'Resume'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.blue); this.elements.pauseBtn.style.width = '38%'; this.elements.closeBtn.style.display = 'inline-block'; this.setButtonColor(this.elements.closeBtn, UIConstants.COLORS.redDim); this.elements.badge.textContent = 'íœ´ì‹ì¤‘'; this.elements.badge.style.background = UIConstants.COLORS.orange; this.updateAction(reason); } updateAction(action) { if (action) { this.elements.action.textContent = action; } } updateCounts() { this.elements.followCount.textContent = this.state.totalFollow; this.elements.surfCount.textContent = this.state.totalSurf; } bindEvents() { this.elements.pauseBtn.onclick = () => { if (this.state.run) { this.setPausedState(); } else { this.setRunningState(); } }; this.elements.closeBtn.onclick = () => { this.destroy(); }; const speedButtons = this.ui.querySelectorAll('[data-speed]'); const speedLabel = this.ui.querySelector('#currentSpeedLabel'); speedButtons.forEach(btn => { btn.onclick = () => { const speed = btn.getAttribute('data-speed'); APITimingConfig.applyPreset(speed); speedButtons.forEach(b => { b.style.background = '#4b5563'; b.style.color = '#fff'; b.style.opacity = '0.7'; b.style.boxShadow = 'none'; }); btn.style.background = '#10b981'; btn.style.color = '#052'; btn.style.opacity = '1'; btn.style.boxShadow = '0 0 0 2px rgba(16,185,129,0.3)'; const labelMap = { 'slow': 'ëŠë¦¼ (ì•ˆì „)', 'normal': 'ë³´í†µ (ê¶Œì¥)', 'fast': 'ë¹ ë¦„ (ì£¼ì˜)' }; speedLabel.textContent = labelMap[speed]; console.log(`âš¡ API ì†ë„ ë³€ê²½: ${labelMap[speed]}`); }; }); addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.elements.pauseBtn.click(); } }); } destroy() { window.__followBot = false; try { this.ui.remove(); } catch (error) { console.warn('UI cleanup error:', error); } } } class StartMenu { constructor() { this.ui = null; this.onSelect = null; } show(onSelect) { this.onSelect = onSelect; this.createMenu(); } showAuthPopup(callback) { const authPopup = document.createElement('div'); authPopup.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2147483648; background: rgba(14,14,16,.98); backdrop-filter: blur(12px); color: #fff; padding: 35px; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.7); font: 14px/1.5 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; text-align: center; min-width: 350px; `; authPopup.innerHTML = ` <div style="margin-bottom: 25px;"> <h2 style="margin: 0 0 12px 0; font-size: 20px; font-weight: 700; color: #fff;"> ğŸ” ì¸ì¦ í•„ìš” </h2> </div> <div style="margin-bottom: 20px;"> <label style="display: block; margin-bottom: 10px; font-size: 13px; font-weight: 600; color: rgba(255,255,255,0.9);"> ì¸ì¦ ë²ˆí˜¸ </label> <div style="display: flex; justify-content: center;"> <input id="authCodeInput" type="text" maxlength="4" placeholder="****" style="width: 140px; padding: 12px 16px; border: 2px solid rgba(255,255,255,0.2); border-radius: 10px; background: rgba(255,255,255,0.1); color: #fff; font-size: 18px; text-align: center; font-weight: 700; letter-spacing: 4px; outline: none; transition: all 0.2s ease;"> </div> </div> <div style="margin-bottom: 20px; padding: 12px; background: rgba(59, 130, 246, 0.15); border-radius: 8px; border: 1px solid rgba(59, 130, 246, 0.3);"> <p style="margin: 0; font-size: 14px; color: #9ccfff; line-height: 1.5;"> ğŸ’¡ ì¸ì¦ë²ˆí˜¸ëŠ” <a href="https://open.kakao.com/o/gZmiqNDh" target="_blank" rel="noopener" style="color: #60a5fa; text-decoration: underline; font-weight: 600;">ë¸”ë¡œê·¸ ì •ë³´ í† ë¡ ë°©</a> ê³µì§€ì—ì„œ í™•ì¸í•˜ì„¸ìš”. </p> </div> <div id="authError" style="display: none; margin-bottom: 15px; padding: 10px; background: rgba(239, 68, 68, 0.15); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3);"> <p style="margin: 0; font-size: 12px; color: #fca5a5; font-weight: 600;"> âŒ ì¸ì¦ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤ </p> </div> <div style="display: flex; gap: 10px;"> <button id="authConfirmBtn" style=" flex: 1; padding: 12px 20px; border: 0; border-radius: 10px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); "> í™•ì¸ </button> <button id="authCancelBtn" style=" flex: 1; padding: 12px 20px; border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.8); font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.2s ease; "> ì·¨ì†Œ </button> </div> `; document.body.appendChild(authPopup); const input = authPopup.querySelector('#authCodeInput'); const confirmBtn = authPopup.querySelector('#authConfirmBtn'); const cancelBtn = authPopup.querySelector('#authCancelBtn'); const errorDiv = authPopup.querySelector('#authError'); setTimeout(() => input.focus(), 100); input.addEventListener('input', () => { errorDiv.style.display = 'none'; input.style.borderColor = 'rgba(255,255,255,0.2)'; }); input.addEventListener('focus', () => { if (errorDiv.style.display === 'none') { input.style.borderColor = 'rgba(16, 185, 129, 0.5)'; } }); input.addEventListener('blur', () => { if (errorDiv.style.display === 'none') { input.style.borderColor = 'rgba(255,255,255,0.2)'; } }); const handleConfirm = () => { const code = input.value.trim(); if (code === AUTH_CODE) { authPopup.remove(); callback(true); } else { errorDiv.style.display = 'block'; input.style.borderColor = 'rgba(239, 68, 68, 0.5)'; input.value = ''; input.focus(); } }; confirmBtn.addEventListener('click', handleConfirm); input.addEventListener('keypress', (e) => { if (e.key === 'Enter') { handleConfirm(); } }); cancelBtn.addEventListener('click', () => { authPopup.remove(); callback(false); }); confirmBtn.onmouseenter = () => { confirmBtn.style.transform = 'translateY(-2px)'; confirmBtn.style.filter = 'brightness(1.1)'; }; confirmBtn.onmouseleave = () => { confirmBtn.style.transform = 'translateY(0)'; confirmBtn.style.filter = 'brightness(1)'; }; cancelBtn.onmouseenter = () => { cancelBtn.style.background = 'rgba(255,255,255,0.1)'; }; cancelBtn.onmouseleave = () => { cancelBtn.style.background = 'rgba(255,255,255,0.05)'; }; } createMenu() { const menu = document.createElement('div'); menu.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2147483647; background: rgba(14,14,16,.95); backdrop-filter: blur(10px); color: #fff; padding: 30px; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.5); font: 14px/1.5 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; text-align: center; width: 320px; `; menu.innerHTML = ` <div style="margin-bottom: 20px;"> <h2 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 700; color: #fff;"> ğŸŒŠ Clip Follow Surfer </h2> <p style="margin: 0; font-size: 12px; opacity: 0.7; color: #9ccfff;"> ìˆ˜í–‰í•  ê¸°ëŠ¥ì„ ì„ íƒí•´ì£¼ì„¸ìš” </p> </div> <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px;"> <button id="followSurfBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); "> ğŸ„â€â™‚ï¸ íŒ”ë¡œìš° íŒŒë„íƒ€ê¸° ì‹œì‘ </button> <button id="excelExportBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); "> ğŸ“Š íŒ”ë¡œìš° í˜„í™© ì—‘ì…€ ì¶œë ¥ </button> <button id="unfollowBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #f59e0b, #d97706); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); "> ğŸ—‘ï¸ ë‚˜ë§Œ íŒ”ë¡œìš° ì œê±° (ë’·ì‚­ ê´€ë¦¬) </button> <button id="refollowBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); "> ğŸ”„ ë‹¤ì‹œ íŒ”ë¡œìš° í•˜ê¸° (ëŒì–´ì˜¬ë¦¬ê¸°) </button> <button id="kakaoChatBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #FEE500, #FFD700); color: #3c1e1e; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(254, 229, 0, 0.3); "> ğŸ’¬ ë¸”ë¡œê·¸ ì •ë³´ í† ë¡ ë°© ì…ì¥ </button> <button id="cancelBtn" style=" padding: 10px 20px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: transparent; color: rgba(255,255,255,0.7); font-weight: 500; cursor: pointer; font-size: 12px; transition: all 0.2s ease; margin-top: 8px; "> ì·¨ì†Œ </button> </div> <div style="border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> ë²„ì „ : ${VERSION} </div> `; document.body.appendChild(menu); this.ui = menu; const buttons = menu.querySelectorAll('button'); buttons.forEach(btn => { btn.onmouseenter = () => { if (btn.id !== 'cancelBtn') { btn.style.transform = 'translateY(-2px)'; btn.style.filter = 'brightness(1.1)'; } else { btn.style.background = 'rgba(255,255,255,0.1)'; } }; btn.onmouseleave = () => { btn.style.transform = 'translateY(0)'; btn.style.filter = 'brightness(1)'; if (btn.id === 'cancelBtn') { btn.style.background = 'transparent'; } }; }); menu.querySelector('#followSurfBtn').onclick = () => { this.showAuthPopup((authorized) => { if (authorized) { this.selectOption('followSurf'); } else { this.createMenu(); } }); }; menu.querySelector('#excelExportBtn').onclick = () => { this.showAuthPopup((authorized) => { if (authorized) { this.selectOption('excelExport'); } else { this.createMenu(); } }); }; menu.querySelector('#unfollowBtn').onclick = () => { this.showAuthPopup((authorized) => { if (authorized) { this.selectOption('unfollowCleanup'); } else { this.createMenu(); } }); }; menu.querySelector('#refollowBtn').onclick = () => { this.showAuthPopup((authorized) => { if (authorized) { this.selectOption('refollowBoost'); } else { this.createMenu(); } }); }; menu.querySelector('#kakaoChatBtn').onclick = () => { window.open('https://open.kakao.com/o/gZmiqNDh', '_blank', 'noopener,noreferrer'); }; menu.querySelector('#cancelBtn').onclick = () => this.selectOption('cancel'); } selectOption(option) { this.destroy(); if (this.onSelect) { this.onSelect(option); } } destroy() { if (this.ui) { this.ui.remove(); this.ui = null; } } } class ClipFollowSurfer { constructor() { this.context = new FeatureContext(new FollowSurfConfig()); this.context.activate(); this.state = new BotState(this.context); this.ui = new BotUI(this.state); this.mainLoop = null; this.uiUpdater = null; this.beforeUnloadHandler = null; this.profileId = null; this.currentTargetPool = []; this.visitedTargets = new Set(); this.recentlyFollowed = new Set(); this.isExecuting = false; this.initialize(); } async initialize() { try { console.log('[ClipFollowSurfer] ì´ˆê¸°í™” ì‹œì‘'); const originalDestroy = this.ui.destroy.bind(this.ui); this.ui.destroy = () => { this.cleanup(); originalDestroy(); }; this.beforeUnloadHandler = () => { console.log('[ClipFollowSurfer] í˜ì´ì§€ ì´íƒˆ ê°ì§€ - ì •ë¦¬ ì‹œì‘'); this.cleanup(); }; window.addEventListener('beforeunload', this.beforeUnloadHandler); this.profileId = Utils.extractProfileId(); console.log('[ClipFollowSurfer] ProfileId:', this.profileId); if (!this.profileId) { console.error('[ClipFollowSurfer] ProfileIdë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'); alert('í”„ë¡œí•„ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); this.cleanup(); return; } const maxFollowersInput = this.ui.ui.querySelector('#maxFollowersInput'); const maxFollowers = maxFollowersInput ? parseInt(maxFollowersInput.value) || 100 : 100; this.ui.updateAction('ğŸ“¥ ì´ˆê¸° ì‹œë“œ ë°ì´í„° ìˆ˜ì§‘ ì¤‘...'); console.log(`[ClipFollowSurfer] ë‚´ íŒ”ë¡œì›Œ ${maxFollowers}ëª…ë§Œ ìˆ˜ì§‘ ì‹œì‘`); this.currentTargetPool = await Utils.fetchFollowData( this.profileId, 'followers', (msg) => this.ui.updateAction(msg), () => !this.state.run, maxFollowers ); console.log(`[ClipFollowSurfer] ì‹œë“œ ë°ì´í„° ${this.currentTargetPool.length}ëª… ìˆ˜ì§‘ ì™„ë£Œ`); if (this.currentTargetPool.length === 0) { console.warn('[ClipFollowSurfer] íŒ”ë¡œì›Œê°€ ì—†ìŠµë‹ˆë‹¤. ëŒ€ì²´ ì‹œë“œ ê³„ì •ì—ì„œ ìˆ˜ì§‘ ì‹œì‘...'); this.ui.updateAction('ğŸ“¥ ëŒ€ì²´ ì‹œë“œ ê³„ì •ì—ì„œ ìˆ˜ì§‘ ì¤‘...'); const fallbackClipId = '4gx01u7b8u'; try { const fallbackProfileId = await Utils.getProfileIdFromClipId(fallbackClipId); if (!fallbackProfileId) { throw new Error('ëŒ€ì²´ ê³„ì •ì˜ profileIdë¥¼ ì–»ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); } this.currentTargetPool = await Utils.fetchFollowData( fallbackProfileId, 'followers', (msg) => this.ui.updateAction(msg), () => !this.state.run, maxFollowers ); console.log(`[ClipFollowSurfer] ëŒ€ì²´ ì‹œë“œ(@${fallbackClipId})ì—ì„œ ${this.currentTargetPool.length}ëª… ìˆ˜ì§‘ ì™„ë£Œ`); } catch (error) { console.error('[ClipFollowSurfer] ëŒ€ì²´ ì‹œë“œ ìˆ˜ì§‘ ì‹¤íŒ¨:', error); } if (this.currentTargetPool.length === 0) { console.error('[ClipFollowSurfer] ëŒ€ì²´ ì‹œë“œì—ì„œë„ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); this.ui.updateAction('âŒ ì‹œë“œ ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨'); alert('íŒŒë„íƒ€ê¸°ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'); this.cleanup(); return; } } console.log('[ClipFollowSurfer] ë©”ì¸ ë£¨í”„ ì‹œì‘'); this.startMainLoop(); this.startUIUpdater(); this.ui.updateAction('âœ… ì´ˆê¸°í™” ì™„ë£Œ, íŒŒë„íƒ€ê¸° ì‹œì‘! ğŸŒŠ'); await Utils.sleep(1000); } catch (error) { console.error('[ClipFollowSurfer] ì´ˆê¸°í™” ì‹¤íŒ¨:', error); console.error('[ClipFollowSurfer] ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack); this.ui.updateAction('âŒ ì´ˆê¸°í™” ì‹¤íŒ¨'); } } startMainLoop() { this.mainLoop = setInterval(async () => { await this.executeMainLoop(); }, APITimingConfig.get('mainLoopInterval')); } async executeMainLoop() { if (this.isExecuting) { console.log('[ClipFollowSurfer] ì´ì „ íŒŒë„íƒ€ê¸° ì‹¤í–‰ ì¤‘, ìŠ¤í‚µ'); return; } if (!this.state.run) { console.log('[ClipFollowSurfer] ì¼ì‹œì •ì§€ ìƒíƒœ, ëŒ€ê¸° ì¤‘...'); return; } if (this.state.totalSurf >= 1000) { console.log('[ClipFollowSurfer] 1000íšŒ ì™„ë£Œ, ì¢…ë£Œ'); this.ui.setPausedState(UIConstants.LABELS.done); return; } this.isExecuting = true; try { console.log(`[ClipFollowSurfer] ===== íŒŒë„íƒ€ê¸° ${this.state.totalSurf + 1}íšŒ ì‹œì‘ =====`); const maxFollowersInput = this.ui.ui.querySelector('#maxFollowersInput'); const maxFollowers = maxFollowersInput ? parseInt(maxFollowersInput.value) || 100 : 100; const availableTargets = this.currentTargetPool.filter( person => !this.visitedTargets.has(person.profileId || person.clipId) ); if (availableTargets.length === 0) { console.log('[ClipFollowSurfer] í˜„ì¬ í’€ ê³ ê°ˆ, ìƒˆë¡œìš´ ì‹œë“œ ìˆ˜ì§‘'); this.ui.updateAction('ğŸ”„ ìƒˆë¡œìš´ ì˜ì—­ íƒìƒ‰ ì¤‘...'); this.currentTargetPool = await Utils.fetchFollowData( this.profileId, 'followers', (msg) => this.ui.updateAction(msg), () => !this.state.run, maxFollowers ); this.visitedTargets.clear(); console.log(`[ClipFollowSurfer] ìƒˆë¡œìš´ ì‹œë“œ ${this.currentTargetPool.length}ëª… ìˆ˜ì§‘ ì™„ë£Œ`); if (this.currentTargetPool.length === 0) { console.warn('[ClipFollowSurfer] ì‹œë“œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); this.ui.updateAction('âš ï¸ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'); return; } availableTargets.length = 0; availableTargets.push(...this.currentTargetPool); } const targetFollower = availableTargets[Math.floor(Math.random() * availableTargets.length)]; const targetProfileId = targetFollower.profileId || targetFollower.clipId; const targetClipId = targetFollower.clipId || targetFollower.nickname; this.visitedTargets.add(targetProfileId); console.log(`[ClipFollowSurfer] ì„ íƒëœ íƒ€ê²Ÿ: @${targetClipId} (${this.visitedTargets.size}/${this.currentTargetPool.length}ë²ˆì§¸ ë°©ë¬¸)`); this.ui.updateAction(`ğŸ” @${targetClipId} íŒ”ë¡œì›Œ íƒìƒ‰ ì¤‘...`); console.log(`[ClipFollowSurfer] íƒ€ê²Ÿì˜ íŒ”ë¡œì›Œ ëª©ë¡ API ì¡°íšŒ ì‹œì‘ (ìµœëŒ€ ${maxFollowers}ëª…)...`); const theirFollowers = await Utils.fetchFollowData( targetProfileId, 'followers', (msg) => this.ui.updateAction(msg), () => !this.state.run, maxFollowers ); console.log(`[ClipFollowSurfer] íƒ€ê²Ÿì˜ íŒ”ë¡œì›Œ ${theirFollowers.length}ëª… ì¡°íšŒ ì™„ë£Œ`); const koreanRegex = /[ê°€-í£ã„±-ã…ã…-ã…£]/; const toFollow = theirFollowers.filter(person => { const id = person.profileId || person.clipId; const nickname = person.nickname || ''; if (id === this.profileId) return false; if (person.follow === true) return false; if (this.recentlyFollowed.has(id)) return false; if (!koreanRegex.test(nickname)) { console.log(`[ClipFollowSurfer] â­ï¸ í•œê¸€ ì—†ëŠ” ë‹‰ë„¤ì„ ìŠ¤í‚µ: ${nickname}`); return false; } return true; }); console.log(`[ClipFollowSurfer] íŒ”ë¡œìš° ê°€ëŠ¥ ëŒ€ìƒ: ${toFollow.length}ëª… (ì „ì²´ ${theirFollowers.length}ëª… ì¤‘, follow=false+í•œê¸€)`); const batchSize = Math.min(10, toFollow.length); console.log(`[ClipFollowSurfer] ì´ë²ˆ ë°°ì¹˜ì—ì„œ ${batchSize}ëª… íŒ”ë¡œìš° ì‹œì‘`); let followedCount = 0; for (let i = 0; i < batchSize; i++) { if (!this.state.run) { console.log('[ClipFollowSurfer] ì¼ì‹œì •ì§€ ê°ì§€, íŒ”ë¡œìš° ì¤‘ë‹¨'); break; } const person = toFollow[i]; const personId = person.clipId || person.nickname; console.log(`[ClipFollowSurfer] [${i+1}/${batchSize}] íŒ”ë¡œìš° ì‹œë„: @${personId} (profileId: ${person.profileId})`); const success = await Utils.followViaGraphQL(person.profileId, person.clipId); if (success) { followedCount++; this.state.totalFollow++; this.recentlyFollowed.add(person.profileId || person.clipId); console.log(`[ClipFollowSurfer] âœ… íŒ”ë¡œìš° ì„±ê³µ: @${personId} (ëˆ„ì : ${this.state.totalFollow}ëª…)`); this.ui.updateAction(`âœ… íŒ”ë¡œìš°: ${personId}`); } else { console.log(`[ClipFollowSurfer] âŒ íŒ”ë¡œìš° ì‹¤íŒ¨: @${personId}`); } const delay = APITimingConfig.getRandomDelay(); console.log(`[ClipFollowSurfer] ë‹¤ìŒ íŒ”ë¡œìš°ê¹Œì§€ ${Math.round(delay)}ms ëŒ€ê¸°...`); await Utils.sleep(delay); } if (theirFollowers.length > 0) { console.log(`[ClipFollowSurfer] ğŸŒŠ íŒŒë„íƒ€ê¸°: ë‹¤ìŒ í’€ì„ í˜„ì¬ íƒìƒ‰ ê²°ê³¼ë¡œ êµì²´ (${theirFollowers.length}ëª…)`); this.currentTargetPool = theirFollowers; this.visitedTargets.clear(); } this.state.totalSurf++; console.log(`[ClipFollowSurfer] íŒŒë„íƒ€ê¸° ì™„ë£Œ: ${followedCount}ëª… íŒ”ë¡œìš° (ì´ ${this.state.totalSurf}/1000íšŒ)`); this.ui.updateAction(`ğŸ„ ${followedCount}ëª… íŒ”ë¡œìš° ì™„ë£Œ (${this.state.totalSurf}/1000)`); const surfDelay = APITimingConfig.get('surfWaitTime'); console.log(`[ClipFollowSurfer] ë‹¤ìŒ íŒŒë„íƒ€ê¸°ê¹Œì§€ ${surfDelay}ms ëŒ€ê¸°...`); await Utils.sleep(surfDelay); console.log(`[ClipFollowSurfer] ===== íŒŒë„íƒ€ê¸° ${this.state.totalSurf}íšŒ ì¢…ë£Œ =====\n`); } catch (error) { console.error('[ClipFollowSurfer] ë©”ì¸ ë£¨í”„ ì˜¤ë¥˜:', error); console.error('[ClipFollowSurfer] ì˜¤ë¥˜ ìŠ¤íƒ:', error.stack); this.ui.updateAction('âš ï¸ ì˜¤ë¥˜ ë°œìƒ, ì¬ì‹œë„ ì¤‘...'); console.log('[ClipFollowSurfer] ì˜¤ë¥˜ ë°œìƒìœ¼ë¡œ 5ì´ˆ ì¶”ê°€ ëŒ€ê¸°...'); await Utils.sleep(5000); } finally { this.isExecuting = false; } } startUIUpdater() { this.uiUpdater = setInterval(() => { this.ui.updateCounts(); }, 1000); } cleanup() { try { console.log('[ClipFollowSurfer] ì •ë¦¬ ì‹œì‘...'); if (this.context) { this.context.deactivate(); this.context = null; } if (this.mainLoop) { clearInterval(this.mainLoop); this.mainLoop = null; } if (this.uiUpdater) { clearInterval(this.uiUpdater); this.uiUpdater = null; } if (this.beforeUnloadHandler) { window.removeEventListener('beforeunload', this.beforeUnloadHandler); this.beforeUnloadHandler = null; } console.log('[ClipFollowSurfer] ì •ë¦¬ ì™„ë£Œ'); } catch (error) { console.warn('[ClipFollowSurfer] Cleanup error:', error); } } } class ExcelExporter { constructor() { this.context = new FeatureContext(new ExcelExportConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.cancelled = false; } async start() { if (!/clip\.naver\.com\/@/.test(location.href)) { alert('clip.naver.com í”„ë¡œí•„ íŒ”ë¡œì›Œ/íŒ”ë¡œì‰ íƒ­ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”'); this.cleanup(); return; } this.createUI(); try { this.profileId = Utils.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileIdë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.loadXLSX(); await this.exportToExcel(); } catch (error) { console.error('Excel export error:', error); this.updateStatus('âš ï¸ ì˜¤ë¥˜: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #3b82f6; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">ì¶”ì¶œì¤‘</span> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">ğŸ“¥ ì¤€ë¹„ ì¤‘...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="closeBtn" style="flex: 1 1 auto; width: 100%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> ë²„ì „ : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; const closeBtn = ui.querySelector('#closeBtn'); Utils.setupCancelButton(closeBtn, this); Utils.addHoverEffects(closeBtn); } updateStatus(message) { Utils.updateStatus(this.ui, message); } async loadXLSX() { if (window.XLSX) return; return new Promise((resolve, reject) => { const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; script.onload = () => resolve(); script.onerror = () => reject(new Error('XLSX ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨')); document.head.appendChild(script); }); } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } async exportToExcel() { const followers = await this.fetchFollowData('followers'); const followings = await this.fetchFollowData('followings'); const followersMap = new Map(followers.map(item => [(item.profileId || item.clipId), item])); const followingsMap = new Map(followings.map(item => [(item.profileId || item.clipId), item])); const allKeys = new Set([...followersMap.keys(), ...followingsMap.keys()]); const merged = []; for (const key of allKeys) { const follower = followersMap.get(key); const following = followingsMap.get(key); const base = follower || following || {}; const iFollow = !!following; const followsMe = !!follower; let relation = 'none'; if (iFollow && followsMe) relation = 'mutual'; else if (iFollow) relation = 'only_me_follow'; else if (followsMe) relation = 'only_them_follow'; merged.push({ profileId: base.profileId || '', clipId: base.clipId || '', nickname: base.nickname || '', profileImageUrl: base.profileImageUrl || '', description: base.description || '', i_follow: iFollow, follows_me: followsMe, relation: relation }); } const workbook = window.XLSX.utils.book_new(); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followers), 'Followers'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followings), 'Followings'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(merged), 'Merged'); const workbookOutput = window.XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }); const blob = new Blob([workbookOutput], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); const now = new Date(); const pad = n => String(n).padStart(2, '0'); link.download = `clip-follow-map-${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}.xlsx`; document.body.appendChild(link); link.click(); URL.revokeObjectURL(link.href); link.remove(); this.updateStatus(`âœ… ì™„ë£Œ! Followers ${followers.length}, Followings ${followings.length}`); setTimeout(() => this.cleanup(), 2500); } cleanup() { if (this.context) this.context.deactivate(); if (this.ui) { this.ui.remove(); this.ui = null; } window.__followBot = false; } } class UnfollowCleaner { constructor() { this.context = new FeatureContext(new UnfollowCleanConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.followingsData = []; this.followersData = []; this.followersMap = new Map(); this.onlyMeFollowList = []; this.processedCount = 0; this.cancelled = false; this.paused = false; this.checkCount = 0; this.unfollowCount = 0; } async start() { if (!/clip\.naver\.com\/@/.test(location.href)) { alert('clip.naver.com í”„ë¡œí•„ í˜ì´ì§€ì—ì„œ ì‹¤í–‰í•´ì£¼ì„¸ìš”'); this.cleanup(); return; } this.createUI(); try { this.profileId = Utils.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileIdë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.collectAndAnalyzeData(); } catch (error) { console.error('Unfollow cleanup error:', error); this.updateStatus('âš ï¸ ì˜¤ë¥˜: ' + error.message); } } async collectAndAnalyzeData() { try { this.updateStatus('ğŸ“¥ íŒ”ë¡œì›Œ ë°ì´í„° ìˆ˜ì§‘ ì¤‘...'); const followers = await this.fetchFollowData('followers'); this.updateStatus('ğŸ“¥ íŒ”ë¡œì‰ ë°ì´í„° ìˆ˜ì§‘ ì¤‘...'); const followings = await this.fetchFollowData('followings'); this.updateStatus('ğŸ” ê´€ê³„ ë¶„ì„ ì¤‘...'); const analysis = this.analyzeFollowRelations(followers, followings); const onlyThemFollowAccounts = analysis.filter(account => account.relation === 'only_them_follow'); const onlyMeFollowAccounts = analysis.filter(account => account.relation === 'only_me_follow'); if (onlyThemFollowAccounts.length === 0 && onlyMeFollowAccounts.length === 0) { this.updateStatus('âœ… ì²˜ë¦¬í•  ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤! (ë§íŒ”/ë’·ì‚­ ëª¨ë‘ ì—†ìŒ)'); setTimeout(() => this.cleanup(), 3000); return; } this.updateStatus(`ğŸ”„ ë§íŒ” ${onlyThemFollowAccounts.length}ê°œ, ì–¸íŒ”ë¡œìš° ${onlyMeFollowAccounts.length}ê°œ ì¤€ë¹„ ì™„ë£Œ`); await Utils.sleep(1000); if (this.cancelled) { console.log('[UnfollowCleaner] ì·¨ì†Œëœ ìƒíƒœë¡œ ì§„í–‰ UI ìƒì„± ê±´ë„ˆëœ€'); return; } this.createProgressUI(); let totalProcessed = 0; let totalSuccess = 0; if (onlyThemFollowAccounts.length > 0) { onlyThemFollowAccounts.reverse(); this.updateProgressStatus(`ğŸ¤ 1ë‹¨ê³„: ë§íŒ” ì‹œì‘ (${onlyThemFollowAccounts.length}ê°œ)`); const followResults = await this.executeGraphQLFollows(onlyThemFollowAccounts); totalProcessed += followResults.processedCount; totalSuccess += followResults.successCount; if (!this.cancelled && onlyMeFollowAccounts.length > 0) { this.updateProgressStatus('1ë‹¨ê³„ ì™„ë£Œ! 2ë‹¨ê³„ ì¤€ë¹„ ì¤‘...'); await Utils.sleep(1000); } } if (onlyMeFollowAccounts.length > 0 && !this.cancelled) { onlyMeFollowAccounts.reverse(); this.updateProgressStatus(`ğŸ—‘ï¸ 2ë‹¨ê³„: ë’·ì‚­ ê´€ë¦¬ ì‹œì‘ (${onlyMeFollowAccounts.length}ê°œ)`); await this.executeGraphQLUnfollows(onlyMeFollowAccounts); } if (!this.cancelled) { const followCount = onlyThemFollowAccounts.length; const unfollowCount = onlyMeFollowAccounts.length; this.updateProgressStatus(`ğŸ‰ ëª¨ë“  ì‘ì—… ì™„ë£Œ! ë§íŒ” ${followCount}ê°œ, ì–¸íŒ”ë¡œìš° ${unfollowCount}ê°œ ì²˜ë¦¬ë¨`); } } catch (error) { console.error('Data collection error:', error); this.updateStatus('âš ï¸ ë°ì´í„° ìˆ˜ì§‘ ì˜¤ë¥˜: ' + error.message); } } analyzeFollowRelations(followers, followings) { const followersMap = new Map(followers.map(item => [(item.profileId || item.clipId), item])); const followingsMap = new Map(followings.map(item => [(item.profileId || item.clipId), item])); const allKeys = new Set([...followersMap.keys(), ...followingsMap.keys()]); const results = []; for (const key of allKeys) { const follower = followersMap.get(key); const following = followingsMap.get(key); const base = follower || following || {}; const iFollow = !!following; const followsMe = !!follower; let relation = 'none'; if (iFollow && followsMe) relation = 'mutual'; else if (iFollow) relation = 'only_me_follow'; else if (followsMe) relation = 'only_them_follow'; results.push({ profileId: base.profileId || '', clipId: base.clipId || '', nickname: base.nickname || '', profileImageUrl: base.profileImageUrl || '', description: base.description || '', i_follow: iFollow, follows_me: followsMe, relation: relation }); } return results; } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #f59e0b; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">ì–¸íŒ”ì¤‘</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px;"> ë°ì´í„° ìˆ˜ì§‘ ì¤‘... </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">ğŸ”„ ë§íŒ” + ë’·ì‚­ ê´€ë¦¬ ì‹œì‘...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> ë²„ì „ : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; this.setupInitialButtons(); } setupInitialButtons() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (!this.paused) { this.paused = true; this.setInitialButtonPausedState(); } else { this.paused = false; this.setInitialButtonRunningState(); } }); closeBtn.addEventListener('click', () => { this.cancelled = true; this.cleanup(); window.__followBot = false; }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); this.setupKeyboardShortcuts(); } setInitialButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ìˆ˜ì§‘ì¤‘'; badge.style.background = '#f59e0b'; } } setInitialButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì¼ì‹œì •ì§€'; badge.style.background = '#f59e0b'; } this.updateStatus('â¸ï¸ ì¼ì‹œì •ì§€ë¨ - Resumeì„ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”'); } createProgressUI() { if (this.cancelled) { console.log('[UnfollowCleaner] ì·¨ì†Œëœ ìƒíƒœë¡œ UI ìƒì„± ê±´ë„ˆëœ€'); return; } if (this.ui) { this.ui.remove(); } this.ui = Utils.createProgressUI( 'ğŸ”„ ë§íŒ” + ë’·ì‚­ ê´€ë¦¬', 'ì‹¤í–‰ì¤‘', '#f59e0b', () => { if (!this.paused) { this.paused = true; this.setButtonPausedState(); } else { this.paused = false; this.setButtonRunningState(); } }, () => { console.log('[UnfollowCleaner] Close ë²„íŠ¼ í´ë¦­ë¨'); this.cancelled = true; this.cleanup(); window.__followBot = false; } ); this.setupKeyboardShortcuts(); } setupKeyboardShortcuts() { this.keydownHandler = (e) => { if (e.key === 'Escape') { const pauseBtn = this.ui.querySelector('#pauseBtn'); if (pauseBtn && pauseBtn.style.display !== 'none') { pauseBtn.click(); } } }; addEventListener('keydown', this.keydownHandler); } removeKeyboardShortcuts() { if (this.keydownHandler) { removeEventListener('keydown', this.keydownHandler); this.keydownHandler = null; } } setButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì–¸íŒ”ì¤‘'; badge.style.background = '#f59e0b'; } } setButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì¼ì‹œì •ì§€'; badge.style.background = '#f59e0b'; } this.updateProgressStatus('â¸ï¸ ì¼ì‹œì •ì§€ë¨ - Resumeì„ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”'); } setButtonCompletedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.style.display = 'none'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'ë‹«ê¸°'; closeBtn.style.background = '#059669'; closeBtn.style.width = '100%'; closeBtn.onclick = () => { this.cleanup(); window.__followBot = false; }; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì™„ë£Œ'; badge.style.background = '#10b981'; } } async executeGraphQLUnfollows(accounts) { const totalCount = accounts.length; let processedCount = 0; let successCount = 0; const totalCountEl = this.ui.querySelector('#totalCount'); if (totalCountEl) totalCountEl.textContent = totalCount; this.updateProgressStatus('ì–¸íŒ”ë¡œìš° ì‹œì‘...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`ì–¸íŒ”ë¡œìš°: ${account.nickname || account.clipId}`); const success = await this.unfollowViaGraphQL(account.profileId, account.clipId); if (success) { successCount++; } else { this.updateProgressStatus(`âŒ ì–¸íŒ”ë¡œìš° ì‹¤íŒ¨: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Unfollow error for', account.clipId, error); this.updateProgressStatus(`âŒ ì˜¤ë¥˜: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = APITimingConfig.getRandomDelay(); await Utils.sleep(delay); } } if (this.cancelled) { this.updateProgressStatus(`ğŸ›‘ ì¤‘ë‹¨ë¨ - ì™„ë£Œ: ${successCount}/${processedCount}`); } else { this.updateProgressStatus(`âœ… ëª¨ë“  ì‘ì—… ì™„ë£Œ! ì„±ê³µ: ${successCount}/${totalCount}`); this.setButtonCompletedState(); } } async unfollowViaGraphQL(profileId, clipId) { return await Utils.unfollowViaGraphQL(profileId, clipId); } async followViaGraphQL(profileId, clipId) { return await Utils.followViaGraphQL(profileId, clipId); } async executeGraphQLFollows(accounts) { const totalCount = accounts.length; let processedCount = 0; let successCount = 0; if (totalCount === 0) { return { processedCount: 0, successCount: 0 }; } this.updateProgressStatus('ë§íŒ” ì‹œì‘...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`ë§íŒ”: ${account.nickname || account.clipId}`); const success = await this.followViaGraphQL(account.profileId, account.clipId); if (success) { successCount++; this.updateProgressStatus(`âœ… ë§íŒ” ì™„ë£Œ: ${account.nickname || account.clipId}`); } else { this.updateProgressStatus(`âŒ ë§íŒ” ì‹¤íŒ¨: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Follow error for', account.clipId, error); this.updateProgressStatus(`âŒ ì˜¤ë¥˜: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = APITimingConfig.getRandomDelay(); await Utils.sleep(delay); } } return { processedCount, successCount }; } updateProgressStatus(message) { const statusEl = this.ui?.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } updateStatus(message) { Utils.updateStatus(this.ui, message); } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } cleanup() { this.removeKeyboardShortcuts(); this.cancelled = true; if (this.context) this.context.deactivate(); if (this.ui) { this.ui.remove(); this.ui = null; } window.__followBot = false; console.log('[UnfollowCleaner] cleanup ì™„ë£Œ'); } } class RefollowBooster { constructor() { this.context = new FeatureContext(new UnfollowCleanConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.cancelled = false; this.paused = false; } async start() { try { if (!location.href.includes('clip.naver.com/@')) { alert('í´ë¦½ í”„ë¡œí•„ í˜ì´ì§€ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.'); return; } this.profileId = Utils.extractProfileId(); if (!this.profileId) { alert('í”„ë¡œí•„ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; } console.log('[RefollowBooster] ëŒì–´ì˜¬ë¦¬ê¸° ì‹œì‘:', this.profileId); this.createUI(); await this.collectAndBoost(); } catch (error) { console.error('RefollowBooster start error:', error); this.updateStatus('âš ï¸ ì˜¤ë¥˜ ë°œìƒ: ' + error.message); setTimeout(() => this.cleanup(), 3000); } } async collectAndBoost() { try { this.updateStatus('ğŸ“¥ íŒ”ë¡œì‰ ëª©ë¡ ìˆ˜ì§‘ ì¤‘...'); const followings = await this.fetchFollowData('followings'); if (this.cancelled) return; if (followings.length === 0) { this.updateStatus('âœ… íŒ”ë¡œì‰í•˜ëŠ” ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤!'); setTimeout(() => this.cleanup(), 3000); return; } this.updateStatus(`ğŸ”„ ì´ ${followings.length}ê°œ ê³„ì • ëŒì–´ì˜¬ë¦¬ê¸° ì¤€ë¹„ ì™„ë£Œ`); await Utils.sleep(1000); this.createProgressUI(); followings.reverse(); await this.executeRefollowBoost(followings); } catch (error) { console.error('Data collection error:', error); this.updateStatus('âš ï¸ ë°ì´í„° ìˆ˜ì§‘ ì˜¤ë¥˜: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #8b5cf6; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">ëŒì˜¬ì¤‘</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px;"> ë°ì´í„° ìˆ˜ì§‘ ì¤‘... </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">ğŸ”„ ëŒì–´ì˜¬ë¦¬ê¸° ì‹œì‘...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> ë²„ì „ : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; this.setupInitialButtons(); } setupInitialButtons() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (!this.paused) { this.paused = true; this.setInitialButtonPausedState(); } else { this.paused = false; this.setInitialButtonRunningState(); } }); closeBtn.addEventListener('click', () => { this.cancelled = true; this.cleanup(); window.__followBot = false; }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); this.setupKeyboardShortcuts(); } setInitialButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ëŒì˜¬ì¤‘'; badge.style.background = '#8b5cf6'; } } setInitialButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì¼ì‹œì •ì§€'; badge.style.background = '#8b5cf6'; } this.updateStatus('â¸ï¸ ì¼ì‹œì •ì§€ë¨ - Resumeì„ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”'); } createProgressUI() { if (this.cancelled) { console.log('[RefollowBooster] ì·¨ì†Œëœ ìƒíƒœë¡œ UI ìƒì„± ê±´ë„ˆëœ€'); return; } if (this.ui) { this.ui.remove(); } this.ui = Utils.createProgressUI( 'Clip Follow Surfer', 'ëŒì˜¬ì¤‘', '#8b5cf6', () => { if (!this.paused) { this.paused = true; this.setButtonPausedState(); } else { this.paused = false; this.setButtonRunningState(); } }, () => { console.log('[RefollowBooster] Close ë²„íŠ¼ í´ë¦­ë¨'); this.cancelled = true; this.cleanup(); window.__followBot = false; } ); } setButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ëŒì˜¬ì¤‘'; badge.style.background = '#8b5cf6'; } } setButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì¼ì‹œì •ì§€'; badge.style.background = '#f59e0b'; } this.updateProgressStatus('â¸ï¸ ì¼ì‹œì •ì§€ë¨ - Resumeì„ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”'); } setButtonCompletedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.style.display = 'none'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.style.width = '100%'; closeBtn.textContent = 'ë‹«ê¸°'; closeBtn.style.background = '#8b5cf6'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = 'ì™„ë£Œ'; badge.style.background = '#8b5cf6'; } } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } async executeRefollowBoost(accounts) { let processedCount = 0; let successCount = 0; const totalCount = accounts.length; const totalCountEl = this.ui.querySelector('#totalCount'); if (totalCountEl) totalCountEl.textContent = totalCount; this.updateProgressStatus('ëŒì–´ì˜¬ë¦¬ê¸° ì‹œì‘...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`ëŒì–´ì˜¬ë¦¬ê¸°: ${account.nickname || account.clipId}`); const unfollowSuccess = await this.unfollowViaGraphQL(account.profileId, account.clipId); if (unfollowSuccess) { await Utils.sleep(200 + Math.random() * 100); const refollowSuccess = await this.followViaGraphQL(account.profileId, account.clipId); if (refollowSuccess) { successCount++; this.updateProgressStatus(`âœ… ëŒì–´ì˜¬ë¦¬ê¸° ì™„ë£Œ: ${account.nickname || account.clipId}`); } else { this.updateProgressStatus(`âŒ ì¬íŒ”ë¡œìš° ì‹¤íŒ¨: ${account.nickname || account.clipId}`); } } else { this.updateProgressStatus(`âŒ ì–¸íŒ”ë¡œìš° ì‹¤íŒ¨: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Refollow boost error for', account.clipId, error); this.updateProgressStatus(`âŒ ì˜¤ë¥˜: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = APITimingConfig.getRandomDelay() * 1.5; await Utils.sleep(delay); } } if (this.cancelled) { this.updateProgressStatus('âŒ ëŒì–´ì˜¬ë¦¬ê¸°ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤'); } else { this.updateProgressStatus(`ğŸ‰ ëŒì–´ì˜¬ë¦¬ê¸° ì™„ë£Œ! ì´ ${successCount}ê°œ ê³„ì • ì²˜ë¦¬ë¨`); this.setButtonCompletedState(); } } async unfollowViaGraphQL(profileId, clipId) { return await Utils.unfollowViaGraphQL(profileId, clipId); } async followViaGraphQL(profileId, clipId) { return await Utils.followViaGraphQL(profileId, clipId); } updateStatus(message) { if (this.ui) { const statusEl = this.ui.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } } updateProgressStatus(message) { if (this.ui) { const statusEl = this.ui.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } } setupKeyboardShortcuts() { this.keyboardHandler = (e) => { if (e.key === 'Escape') { e.preventDefault(); const pauseBtn = this.ui?.querySelector('#pauseBtn'); if (pauseBtn) { pauseBtn.click(); } } }; document.addEventListener('keydown', this.keyboardHandler); } removeKeyboardShortcuts() { if (this.keyboardHandler) { document.removeEventListener('keydown', this.keyboardHandler); this.keyboardHandler = null; } } cleanup() { this.cancelled = true; this.removeKeyboardShortcuts(); if (this.ui) { this.ui.remove(); this.ui = null; } if (this.context) this.context.deactivate(); window.__followBot = false; console.log('[RefollowBooster] cleanup ì™„ë£Œ'); } } class App { static start() { const menu = new StartMenu(); menu.show((option) => { switch (option) { case 'followSurf': new ClipFollowSurfer(); break; case 'excelExport': new ExcelExporter().start(); break; case 'unfollowCleanup': new UnfollowCleaner().start(); break; case 'refollowBoost': new RefollowBooster().start(); break; case 'cancel': window.__followBot = false; break; } }); } } App.start(); })();
