javascript:(() => { const VERSION = '2025.10.04 00:00:00'; 'use strict'; if (window.__followBot) { alert('Already running'); return; } window.__followBot = true; class FeatureConfig { constructor(name, options = {}) { this.featureName = name; this.allowFollowing = options.allowFollowing ?? true; this.allowSurfing = options.allowSurfing ?? true; this.allowScrolling = options.allowScrolling ?? true; this.allowDynamicLoading = options.allowDynamicLoading ?? true; this.customDelay = options.customDelay ?? null; this.maxOperations = options.maxOperations ?? null; this.onlyClipIdMatching = options.onlyClipIdMatching ?? false; this.scrollToTopAfterAction = options.scrollToTopAfterAction ?? true; this.requirements = options.requirements ?? []; this.restrictions = options.restrictions ?? []; } isAllowed(action) { const actionMap = { 'follow': this.allowFollowing, 'surf': this.allowSurfing, 'scroll': this.allowScrolling, 'dynamicLoad': this.allowDynamicLoading }; return actionMap[action] ?? false; } checkRestrictions(context) { return this.restrictions.every(restriction => { if (typeof restriction === 'function') { return restriction(context); } return true; }); } checkRequirements(context) { return this.requirements.every(requirement => { if (typeof requirement === 'function') { return requirement(context); } return true; }); } } class FollowSurfConfig extends FeatureConfig { constructor() { super('FollowSurf', { allowFollowing: true, allowSurfing: true, allowScrolling: true, allowDynamicLoading: true, maxOperations: 100, requirements: [ (context) => context.state.totalSurf < 100 ] }); } } class ExcelExportConfig extends FeatureConfig { constructor() { super('ExcelExport', { allowFollowing: false, allowSurfing: false, allowScrolling: true, allowDynamicLoading: true, onlyClipIdMatching: true, scrollToTopAfterAction: false, requirements: [ (context) => window.location.href.includes('clip.naver.com/@') ] }); } } class UnfollowCleanConfig extends FeatureConfig { constructor() { super('UnfollowClean', { allowFollowing: false, allowSurfing: false, allowScrolling: true, allowDynamicLoading: true, onlyClipIdMatching: true, scrollToTopAfterAction: false, customDelay: 1200, restrictions: [ (context) => !context.state.followingProcessing ] }); } } class FeatureContext { constructor(config) { this.config = config; this.state = this.createFeatureState(); this.isActive = false; } createFeatureState() { const baseState = { run: true, delay: this.config.customDelay || 650, scrollDelay: 2000, currentPage: 'unknown', lastScrollY: 0, stableScrollCount: 0 }; switch (this.config.featureName) { case 'FollowSurf': return { ...baseState, empty: 0, totalFollow: 0, totalSurf: 0, clickedButtons: new Set(), followedAccounts: new Set(), dynamicLoads: 0, justSurfed: false, followingProcessing: false }; case 'ExcelExport': return { ...baseState, collectedData: { followers: [], following: [] }, collectionProgress: 0, totalToCollect: 0, isCollecting: false }; case 'UnfollowClean': return { ...baseState, followersMap: new Map(), unfollowCount: 0, processedButtons: new Set(), totalProcessed: 0, isProcessing: false }; default: return baseState; } } canPerform(action) { return this.isActive && this.config.isAllowed(action) && this.config.checkRequirements(this) && this.config.checkRestrictions(this); } activate() { this.isActive = true; console.log(`[${this.config.featureName}] 기능 활성화됨`); } deactivate() { this.isActive = false; console.log(`[${this.config.featureName}] 기능 비활성화됨`); } reset() { const oldState = this.state; this.state = this.createFeatureState(); this.state.run = oldState.run; console.log(`[${this.config.featureName}] 상태 초기화됨`); } } class BotState { constructor(context = null) { this.context = context; } get run() { return this.context?.state.run ?? true; } set run(value) { if (this.context) this.context.state.run = value; } get delay() { return this.context?.state.delay ?? 650; } get scrollDelay() { return this.context?.state.scrollDelay ?? 2000; } get empty() { return this.context?.state.empty ?? 0; } set empty(value) { if (this.context) this.context.state.empty = value; } get totalFollow() { return this.context?.state.totalFollow ?? 0; } set totalFollow(value) { if (this.context) this.context.state.totalFollow = value; } get totalSurf() { return this.context?.state.totalSurf ?? 0; } set totalSurf(value) { if (this.context) this.context.state.totalSurf = value; } get clickedButtons() { return this.context?.state.clickedButtons ?? new Set(); } get followedAccounts() { return this.context?.state.followedAccounts ?? new Set(); } get currentPage() { return this.context?.state.currentPage ?? 'unknown'; } set currentPage(value) { if (this.context) this.context.state.currentPage = value; } get lastScrollY() { return this.context?.state.lastScrollY ?? 0; } set lastScrollY(value) { if (this.context) this.context.state.lastScrollY = value; } get stableScrollCount() { return this.context?.state.stableScrollCount ?? 0; } set stableScrollCount(value) { if (this.context) this.context.state.stableScrollCount = value; } get dynamicLoads() { return this.context?.state.dynamicLoads ?? 0; } set dynamicLoads(value) { if (this.context) this.context.state.dynamicLoads = value; } get justSurfed() { return this.context?.state.justSurfed ?? false; } set justSurfed(value) { if (this.context) this.context.state.justSurfed = value; } setContext(context) { this.context = context; } reset() { if (this.context) { this.context.reset(); } } setJustSurfed() { if (this.context && this.context.state.justSurfed !== undefined) { this.context.state.justSurfed = true; setTimeout(() => { if (this.context) { this.context.state.justSurfed = false; } }, 5000); } } } class Utils { static queryAll(selector, searchArea = document) { return Array.from(searchArea.querySelectorAll(selector)); } static normalizeText(element) { return (element.textContent || '').replace(/\s+/g, '').trim(); } static isVisible(element) { const rect = element.getBoundingClientRect(); return rect.bottom >= -800 && rect.top <= innerHeight + 800; } static sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } static scrollToCenter(element) { element.scrollIntoView({ block: 'center', behavior: 'smooth' }); } static simulateMouseEvents(element) { const events = ['mouseover', 'mousedown', 'mouseup']; events.forEach(eventType => { element.dispatchEvent(new MouseEvent(eventType, { bubbles: true })); }); } static getFixedUIStyles() { return ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: rgba(14,14,16,.88); backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,.35); font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; } static getServiceHeaderHTML() { return ` <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.16); padding-bottom: 6px; font-size: 12px; font-weight: 600; text-align: center;"> 늑대왕의 블로그 정보 토론방: <a href="https://open.kakao.com/o/gZmiqNDh" target="_blank" rel="noopener" style="color: #9ccfff; text-decoration: underline;">들어가기</a> </div> `; } static addHoverEffects(button) { button.onmouseenter = () => button.style.filter = 'brightness(1.06)'; button.onmouseleave = () => button.style.filter = 'none'; button.onmousedown = () => button.style.transform = 'scale(0.98)'; button.onmouseup = () => button.style.transform = 'scale(1)'; } static extractProfileId() { try { const html = document.documentElement.innerHTML; const matches = [...html.matchAll(/"profileId":"([A-Za-z0-9_\-]+)"/g)].map(x => x[1]); if (matches.length) { const frequency = matches.reduce((acc, val) => (acc[val] = (acc[val] || 0) + 1, acc), {}); return Object.entries(frequency).sort((a, b) => b[1] - a[1])[0][0]; } } catch (error) { console.warn('Profile ID extraction error:', error); } return null; } static updateStatus(ui, message) { if (ui) { const statusText = ui.querySelector('#statusText'); if (statusText) { statusText.textContent = message; } else { ui.textContent = message; } } } static cleanup(ui, message = null, delay = 1000) { if (message) { this.updateStatus(ui, message); } const doCleanup = () => { if (ui) { ui.remove(); } }; if (delay > 0) { setTimeout(doCleanup, delay); } else { doCleanup(); } } static setupCancelButton(button, instance) { button.onclick = () => { instance.cancelled = true; instance.updateStatus('❌ 사용자가 중단했습니다'); setTimeout(() => instance.cleanup(), 1000); }; } static async fetchFollowData(profileId, type, statusCallback, cancelCallback) { const endpoint = '/api/graphql'; const queries = { followers: `query userFollowersInfinitePaginationQuery($after:String,$first:Int,$input:FollowersInput!,$nextCursor:String){...userFollowersPaginationRefetchableFragment_2lRZMj}fragment userFollowersPaginationRefetchableFragment_2lRZMj on Query{followers(input:$input,after:$after,first:$first,nextCursor:$nextCursor){edges{cursor node{profileId nickname...userUsersPaginationItem id __typename}}pageInfo{hasNextPage totalCount endCursor}nextCursor}}fragment userUsersPaginationItem on User{id profileId clipId nickname profileImageUrl description follow}`, followings: `query userFollowingsInfinitePaginationQuery($after:String,$first:Int,$input:FollowingsInput!,$nextCursor:String){...userFollowingsPaginationRefetchableFragment_2lRZMj}fragment userFollowingsPaginationRefetchableFragment_2lRZMj on Query{followings(input:$input,after:$after,first:$first,nextCursor:$nextCursor){edges{cursor node{profileId nickname...userUsersPaginationItem id __typename}}pageInfo{hasNextPage totalCount endCursor}nextCursor}}fragment userUsersPaginationItem on User{id profileId clipId nickname profileImageUrl description follow}` }; const query = queries[type]; const key = type; let cursor = null; let nextCursor = null; const results = []; for (let i = 0; i < 9999; i++) { if (cancelCallback && cancelCallback()) break; if (statusCallback) { statusCallback(`📥 ${type} ${results.length}개 수집 중...`); } const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 20, input: { profileId: profileId }, nextCursor: nextCursor } }) }); const data = await response.json(); const root = data.data[key]; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) { continue; } results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; nextCursor = root.nextCursor; await Utils.sleep(350 + Math.random() * 250); } return results; } static async followViaGraphQL(profileId, clipId) { try { const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7', 'content-type': 'application/json', 'Referer': `https://clip.naver.com/@${clipId}/follow?tab=following` }, body: JSON.stringify({ query: `mutation userFollowUserMutation($input:FollowUserInput!){followUser(input:$input){__typename...on FollowUserSucceed{success}...on CommonError{message code}}}`, variables: { input: { profileId: profileId } } }) }); const result = await response.json(); return result.data?.followUser?.__typename === 'FollowUserSucceed'; } catch (error) { console.error('Follow GraphQL error:', error); return false; } } static async unfollowViaGraphQL(profileId, clipId) { try { const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7', 'content-type': 'application/json', 'Referer': `https://clip.naver.com/@${clipId}/follow?tab=following` }, body: JSON.stringify({ query: `mutation userUnfollowUserMutation($input:UnfollowUserInput!){unfollowUser(input:$input){__typename...on UnfollowUserSucceed{success}...on CommonError{message code}}}`, variables: { input: { profileId: profileId } } }) }); const result = await response.json(); return result.data?.unfollowUser?.__typename === 'UnfollowUserSucceed'; } catch (error) { console.error('Unfollow GraphQL error:', error); return false; } } static createProgressUI(title, badgeText, badgeColor, onPause, onClose) { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">${title}</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: ${badgeColor}; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">${badgeText}</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px; text-align: center;"> 진행: <b id="processedCount">0</b> / <b id="totalCount">0</b> | 성공: <b id="successCount">0</b> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">준비 중...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); Utils.setupProgressButtons(ui, onPause, onClose); return ui; } static setupProgressButtons(ui, onPause, onClose) { const pauseBtn = ui.querySelector('#pauseBtn'); const closeBtn = ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (onPause) onPause(); }); closeBtn.addEventListener('click', () => { if (onClose) onClose(); }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); } } class UIConstants { static COLORS = { red: '#ef4444', redDim: '#b91c1c', blue: '#3b82f6', green: '#10b981', orange: '#f59e0b', bg: 'rgba(14,14,16,.88)', cardShadow: '0 8px 30px rgba(0,0,0,.35)' }; static LABELS = { follow: '팔로우', surf: '파도타기', paused: '일시정지', done: '100회 완료' }; } class BotUI { constructor(state) { this.state = state; this.elements = {}; this.createUI(); this.bindEvents(); } createUI() { const ui = document.createElement('div'); ui.style.cssText = this.getMainUIStyles(); ui.innerHTML = this.getUITemplate(); document.body.appendChild(ui); this.ui = ui; this.cacheElements(); this.setupButtons(); } getMainUIStyles() { return ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: ${UIConstants.COLORS.bg}; backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: ${UIConstants.COLORS.cardShadow}; font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; } getUITemplate() { return ` ${Utils.getServiceHeaderHTML()} <div style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:4px"> <b style="font-size:13px">Clip Follow Surfer</b> <span id="badge" style="padding:2px 8px;border-radius:999px;background:#10b981;color:#052;font-weight:700;font-size:10px;letter-spacing:.25px"> 서핑중 </span> </div> <div id="stats" style="opacity:.95;font-size:11px;line-height:1.4"> 팔로우: <b id="followCount">0</b> | 파도타기: <b id="surfCount">0</b><br> 동적로딩: <span id="dynamicCount">0</span> | 연속미탐지: <span id="emptyCount">0</span> </div> <div id="currentAction" style="opacity:.8;font-size:10px;color:#9ccfff;margin:4px 0;min-height:15px;display:flex;align-items:center;justify-content:center"> 탐지중... </div> <div id="btnRow" style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;justify-content:center"> <button id="pauseBtn" style="flex:1 1 auto;width:80%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease"> Stop </button> <button id="closeBtn" style="flex:1 1 auto;width:38%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease;display:none"> Close </button> </div> <div style="margin-top:10px;border-top:1px solid rgba(255,255,255,.16);padding-top:8px;font-size:10px;opacity:.7"> 버전 : ${VERSION} </div> `; } cacheElements() { this.elements = { stats: this.ui.querySelector('#stats'), pauseBtn: this.ui.querySelector('#pauseBtn'), closeBtn: this.ui.querySelector('#closeBtn'), badge: this.ui.querySelector('#badge'), action: this.ui.querySelector('#currentAction'), followCount: this.ui.querySelector('#followCount'), surfCount: this.ui.querySelector('#surfCount'), dynamicCount: this.ui.querySelector('#dynamicCount'), emptyCount: this.ui.querySelector('#emptyCount') }; } setupButtons() { this.addHoverEffects(this.elements.pauseBtn); this.addHoverEffects(this.elements.closeBtn); this.setRunningState(); } addHoverEffects(button) { Utils.addHoverEffects(button); } setButtonColor(button, backgroundColor) { button.style.background = backgroundColor; button.style.color = '#fff'; } setRunningState() { this.state.run = true; this.elements.pauseBtn.textContent = 'Stop'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.red); this.elements.pauseBtn.style.width = '80%'; this.elements.closeBtn.style.display = 'none'; this.elements.badge.textContent = '서핑중'; this.elements.badge.style.background = UIConstants.COLORS.green; this.updateAction('동작중...'); } setPausedState(reason = UIConstants.LABELS.paused) { this.state.run = false; this.elements.pauseBtn.textContent = 'Resume'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.blue); this.elements.pauseBtn.style.width = '38%'; this.elements.closeBtn.style.display = 'inline-block'; this.setButtonColor(this.elements.closeBtn, UIConstants.COLORS.redDim); this.elements.badge.textContent = '휴식중'; this.elements.badge.style.background = UIConstants.COLORS.orange; this.updateAction(reason); } updateAction(action) { if (action) { this.elements.action.textContent = action; } } updateCounts() { this.elements.followCount.textContent = this.state.totalFollow; this.elements.surfCount.textContent = this.state.totalSurf; this.elements.dynamicCount.textContent = this.state.dynamicLoads; this.elements.emptyCount.textContent = this.state.empty; } bindEvents() { this.elements.pauseBtn.onclick = () => { if (this.state.run) { this.setPausedState(); } else { this.setRunningState(); } }; this.elements.closeBtn.onclick = () => { this.destroy(); }; addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.elements.pauseBtn.click(); } }); } destroy() { window.__followBot = false; try { this.ui.remove(); } catch (error) { console.warn('UI cleanup error:', error); } } } class PageDetector { constructor(state) { this.state = state; } detectPageType() { if (location.pathname.includes('/@')) { const profileElements = Utils.queryAll('[class*="UIProfileInfo"],[class*="UIProfileHeader"]'); if (profileElements.length > 0) { this.state.currentPage = 'profile'; return 'profile'; } } const listElements = Utils.queryAll('li[class*="UIProfileListItem"]'); const followSectionElements = Utils.queryAll('[class*="MyFollowProfileSection"]'); if (listElements.length > 0 || followSectionElements.length > 0) { this.state.currentPage = 'list'; return 'list'; } this.state.currentPage = 'unknown'; return 'unknown'; } isFollowingButton(button) { const text = Utils.normalizeText(button); return /팔로잉|Following|언팔로우/.test(text) || button.getAttribute('aria-pressed') === 'true'; } findFollowableButtons() { const buttonSelectors = 'button,a,[role="button"]'; const buttons = Utils.queryAll(buttonSelectors); return buttons.filter(button => { const text = Utils.normalizeText(button); const isFollowBtn = /팔로우/.test(text) && !/팔로잉|팔로우중|Following|언팔로우/i.test(text) && !this.isFollowingButton(button); const isEnabled = !button.closest('[disabled],[aria-disabled="true"]') && button.getAttribute('aria-pressed') !== 'true'; const accountId = this.extractAccountIdFromButton(button); const notFollowed = !this.state.followedAccounts.has(accountId); const buttonId = this.ensureButtonId(button); const notClicked = !this.state.clickedButtons.has(buttonId); return isFollowBtn && isEnabled && notFollowed && notClicked; }); } findSurfableProfiles() { const candidates = []; const listSelector = 'li[class*="UIProfileListItem_list_item"]'; const listItems = Utils.queryAll(listSelector); for (const item of listItems) { const link = item.querySelector('a[class*="UIProfileListItem_link"]'); const txtArea = item.querySelector('[class*="UIProfileListItem_txt_area"]'); if (link && txtArea) { const id = txtArea.textContent?.trim(); if (id && id.length > 0) { candidates.push({ id: id, link: link, element: item }); } } } const recommendItems = Utils.queryAll('[class*="UIRecommendCreatorCarouselType_list_item"]'); for (const item of recommendItems) { const link = item.querySelector('a[class*="UIRecommendCreatorCarouselType_link"]'); const txtArea = item.querySelector('[class*="UIRecommendCreatorCarouselType_txt_area"]'); const titArea = item.querySelector('[class*="UIRecommendCreatorCarouselType_tit_area"]'); if (link && (txtArea || titArea)) { const textElement = txtArea && txtArea.textContent?.trim() ? txtArea : titArea; const id = textElement?.textContent?.trim(); if (id && id.length > 0) { candidates.push({ id: id, link: link, element: item }); } } } const uniqueCandidates = []; const seenIds = new Set(); for (const candidate of candidates) { if (!seenIds.has(candidate.id)) { seenIds.add(candidate.id); uniqueCandidates.push(candidate); } } return uniqueCandidates; } ensureButtonId(button) { if (!button.dataset.buttonId) { button.dataset.buttonId = 'btn_' + Math.random().toString(36).substr(2, 9); } return button.dataset.buttonId; } extractAccountIdFromButton(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const clipIdElement = parent.querySelector('[class*="UIRecommendCreatorCarouselType_txt_area"]'); if (clipIdElement) { const clipId = clipIdElement.textContent?.trim(); if (clipId && clipId.length > 0 && !clipId.includes('팔로우')) { return clipId.replace(/^@/, ''); } } const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return accountId.replace(/^@/, ''); } } const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) { return decodeURIComponent(match[1]); } } } return this.extractIdFromElement(button) || 'unknown_' + Math.random().toString(36).substr(2, 9); } extractAccountName(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return '@' + accountId; } } const nameElement = parent.querySelector('[class*="UIProfileListItem_tit_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (nameElement) { const accountName = nameElement.textContent?.trim(); if (accountName && accountName.length > 0 && !accountName.includes('팔로우')) { return accountName.slice(0, 15); } } } return '알수없음'; } extractIdFromElement(element) { if (!element) return null; const href = element.getAttribute && element.getAttribute('href'); if (href) { const match = href.match(/\/@([^/?#]+)/); if (match) { return decodeURIComponent(match[1]); } } const text = (element.innerText || element.textContent || '').trim(); const textMatch = text.match(/@([A-Za-z0-9._-]{3,32})/); if (textMatch) { return textMatch[1]; } return null; } gotoFollowerTab() { const followerTab = Utils.queryAll('a,button,[role="button"]') .find(element => /팔로워/i.test(element.textContent || '')); if (followerTab) { followerTab.click(); return true; } return false; } } class BotActions { constructor(context, ui, detector) { this.context = context; this.ui = ui; this.detector = detector; this.state = ui?.state || context?.state || {}; } canPerform(action) { return this.context ? this.context.canPerform(action) : false; } async ensureMoreCandidates() { const listSelector = 'li[class*="UIProfileListItem_list_item"],li[class^="UIProfileListItem_list_item"]'; const visibleItems = Utils.queryAll(listSelector).filter(Utils.isVisible); if (visibleItems.length <= 3) { this.ui.updateAction('더 많은 후보 로딩중...'); scrollBy(0, window.innerHeight * 0.8); await Utils.sleep(500); this.state.dynamicLoads++; } } async triggerDynamicLoading() { this.ui.updateAction('동적 로딩 중...'); scrollBy(0, window.innerHeight * 1.5); await Utils.sleep(800); this.state.dynamicLoads++; this.ui.updateAction('동적 로딩 완료'); return true; } async clickRecommendButtons() { let clickCount = 0; const recommendSelector = '[class*="MyFollowProfileSection_recommend_area"] button,[class*="MyFollowProfileSection_recommend_area"] a,[class*="MyFollowProfileSection_recommend_area"] [role="button"]'; const recommendButtons = Utils.queryAll(recommendSelector).filter(button => { const text = Utils.normalizeText(button); const isFollowBtn = /팔로우/.test(text) && !/팔로잉|Following/i.test(text) && !this.detector.isFollowingButton(button); const isEnabled = !button.closest('[disabled],[aria-disabled="true"]') && button.getAttribute('aria-pressed') !== 'true'; const accountId = this.detector.extractAccountIdFromButton(button); const notFollowed = !this.state.followedAccounts.has(accountId); const buttonId = this.detector.ensureButtonId(button); const notClicked = !this.state.clickedButtons.has(buttonId); return isFollowBtn && isEnabled && notFollowed && notClicked; }); this.ui.updateAction(`창작자 추천: ${recommendButtons.length}개`); for (const button of recommendButtons) { if (this.detector.isFollowingButton(button)) continue; const accountId = this.detector.extractAccountIdFromButton(button); if (this.state.followedAccounts.has(accountId)) continue; const buttonId = button.dataset.buttonId; if (this.state.clickedButtons.has(buttonId)) continue; this.state.followedAccounts.add(accountId); this.state.clickedButtons.add(buttonId); Utils.scrollToCenter(button); const isVisible = Utils.isVisible(button); await Utils.sleep(isVisible ? 300 : 800); const accountName = this.detector.extractAccountName(button); Utils.simulateMouseEvents(button); button.click(); clickCount++; this.state.totalFollow++; this.ui.updateAction(`추천 팔로우: ${accountName}${isVisible ? '' : '(스크롤됨)'}`); await Utils.sleep(this.state.delay); } return clickCount; } async getProfileIdByClipId(clipId) { try { console.log('🔍 API로 profileId 조회:', clipId); const response = await fetch('https://clip.naver.com/api/graphql', { method: 'POST', headers: { 'accept': 'application/json', 'content-type': 'application/json' }, body: JSON.stringify({ query: "query UserQuery($clipId:String!){user(clipId:$clipId){__typename...on UserSucceed{user{profileId clipId nickname}}}}", variables: { clipId: clipId } }) }); const result = await response.json(); console.log('📥 API 응답:', result); if (result.data?.user?.__typename === 'UserSucceed') { const profileId = result.data.user.user.profileId; console.log('✅ API에서 profileId 찾음:', profileId); return profileId; } console.log('❌ API에서 profileId 찾지 못함:', clipId); return null; } catch (error) { console.error('💥 API 조회 에러:', error); return null; } } async findProfileIdByClipId(clipId) { try { const html = document.documentElement.innerHTML; const patterns = [ new RegExp(`"clipId":"${clipId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}"[^}]*"profileId":"([A-Za-z0-9_\\-]+)"`, 'g'), new RegExp(`"profileId":"([A-Za-z0-9_\\-]+)"[^}]*"clipId":"${clipId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}"`, 'g') ]; for (const pattern of patterns) { const match = pattern.exec(html); if (match) { console.log('✅ HTML에서 profileId 찾음:', match[1]); return match[1]; } } const nextDataScript = document.getElementById('__NEXT_DATA__'); if (nextDataScript) { const data = JSON.parse(nextDataScript.textContent); const initialRecords = data?.props?.pageProps?.initialRecords; if (initialRecords) { for (const [key, value] of Object.entries(initialRecords)) { if (value?.__typename === 'User' && value?.clipId === clipId) { console.log('✅ __NEXT_DATA__에서 profileId 찾음:', value.profileId); return value.profileId; } } } } console.log('🔄 API로 profileId 조회 시도...'); return await this.getProfileIdByClipId(clipId); } catch (error) { console.error('💥 profileId 찾기 에러:', error); return null; } } markButtonAsAPIProcessed(button, success) { button.classList.remove('api-success', 'api-failed'); if (success) { button.classList.add('api-success'); button.style.cssText += ` background: linear-gradient(45deg, #10b981, #059669) !important; border-color: #059669 !important; box-shadow: 0 0 10px rgba(16, 185, 129, 0.5) !important; `; } else { button.classList.add('api-failed'); button.style.cssText += ` background: linear-gradient(45deg, #ef4444, #dc2626) !important; border-color: #dc2626 !important; box-shadow: 0 0 10px rgba(239, 68, 68, 0.5) !important; `; } } updateButtonToFollowingState(button) { try { const textNodes = button.childNodes; textNodes.forEach(node => { if (node.nodeType === Node.TEXT_NODE && /팔로우/.test(node.textContent)) { node.textContent = node.textContent.replace(/팔로우/g, '팔로잉'); } }); const textElements = button.querySelectorAll('*'); textElements.forEach(el => { if (el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE) { el.textContent = el.textContent.replace(/팔로우/g, '팔로잉'); } }); button.setAttribute('aria-pressed', 'true'); button.setAttribute('aria-label', '팔로잉'); button.classList.add('following', 'followed'); console.log('🔄 버튼 상태를 팔로잉으로 업데이트:', button.textContent); } catch (error) { console.error('버튼 상태 업데이트 실패:', error); } } async followRecommendViaGraphQL() { const recommendSelector = 'a[class*="UIRecommendCreatorCarouselType_btn_follow"],button[class*="UIRecommendCreatorCarouselType_btn_follow"]'; const recommendButtons = Utils.queryAll(recommendSelector).filter(button => { const text = Utils.normalizeText(button); const isFollowBtn = /팔로우/.test(text) && !/팔로잉|Following/i.test(text) && !this.detector.isFollowingButton(button); const isEnabled = !button.closest('[disabled],[aria-disabled="true"]') && button.getAttribute('aria-pressed') !== 'true'; const accountId = this.detector.extractAccountIdFromButton(button); const notFollowed = !this.state.followedAccounts.has(accountId); const buttonId = this.detector.ensureButtonId(button); const notClicked = !this.state.clickedButtons.has(buttonId); return isFollowBtn && isEnabled && notFollowed && notClicked; }); this.ui.updateAction(`창작자 추천: ${recommendButtons.length}개`); let followCount = 0; for (const button of recommendButtons) { if (this.detector.isFollowingButton(button)) continue; const accountId = this.detector.extractAccountIdFromButton(button); if (this.state.followedAccounts.has(accountId)) continue; const buttonId = button.dataset.buttonId; if (this.state.clickedButtons.has(buttonId)) continue; const clipId = accountId; if (!clipId || clipId.startsWith('unknown_')) { console.log('❌ [추천] clipId 추출 실패:', clipId); continue; } const profileId = await this.findProfileIdByClipId(clipId); if (!profileId) { console.log('❌ [추천] profileId 찾지 못함:', clipId); continue; } console.log('🔍 [추천] 팔로우 시도:', { profileId, clipId, accountName: this.detector.extractAccountName(button) }); this.state.followedAccounts.add(accountId); this.state.clickedButtons.add(buttonId); Utils.scrollToCenter(button); const isVisible = Utils.isVisible(button); await Utils.sleep(isVisible ? 300 : 800); const accountName = this.detector.extractAccountName(button); this.ui.updateAction(`추천 팔로우 API 호출: ${accountName}`); const success = await this.followViaGraphQL(profileId, clipId); console.log(success ? '✅ [추천] 팔로우 성공:' : '❌ [추천] 팔로우 실패:', { profileId, clipId, accountName }); if (success) { followCount++; this.state.totalFollow++; this.markButtonAsAPIProcessed(button, true); this.updateButtonToFollowingState(button); this.ui.updateAction(`✅ 추천 팔로우 완료: ${accountName}${isVisible ? '' : '(스크롤됨)'}`); } else { this.markButtonAsAPIProcessed(button, false); this.ui.updateAction(`❌ 추천 팔로우 실패: ${accountName}`); } await Utils.sleep(this.state.delay); } return followCount; } async followAllViaGraphQL() { if (!this.canPerform('follow')) { return 0; } let followCount = 0; const hasRecommendArea = Utils.queryAll('[class*="MyFollowProfileSection_recommend_area"]').length > 0; if (hasRecommendArea) { followCount += await this.followRecommendViaGraphQL(); } const followButtons = this.detector.findFollowableButtons(); this.ui.updateAction(`일반 팔로우: ${followButtons.length}개`); for (const button of followButtons) { if (this.detector.isFollowingButton(button)) continue; const accountId = this.detector.extractAccountIdFromButton(button); if (this.state.followedAccounts.has(accountId)) continue; const buttonId = button.dataset.buttonId; if (this.state.clickedButtons.has(buttonId)) continue; const clipId = accountId; if (!clipId || clipId.startsWith('unknown_')) { console.log('❌ clipId 추출 실패:', clipId); continue; } const profileId = await this.findProfileIdByClipId(clipId); if (!profileId) { console.log('❌ profileId 찾지 못함:', clipId); continue; } console.log('🔍 팔로우 시도:', { profileId, clipId, accountName: this.detector.extractAccountName(button) }); this.state.followedAccounts.add(accountId); this.state.clickedButtons.add(buttonId); Utils.scrollToCenter(button); const isVisible = Utils.isVisible(button); await Utils.sleep(isVisible ? 300 : 800); const accountName = this.detector.extractAccountName(button); this.ui.updateAction(`팔로우 API 호출: ${accountName}`); const success = await this.followViaGraphQL(profileId, clipId); console.log(success ? '✅ 팔로우 성공:' : '❌ 팔로우 실패:', { profileId, clipId, accountName }); if (success) { followCount++; this.state.totalFollow++; this.markButtonAsAPIProcessed(button, true); this.updateButtonToFollowingState(button); this.ui.updateAction(`✅ 팔로우 완료: ${accountName}${isVisible ? '' : '(스크롤됨)'}`); } else { this.markButtonAsAPIProcessed(button, false); this.ui.updateAction(`❌ 팔로우 실패: ${accountName}`); } await Utils.sleep(this.state.delay); } if (followCount === 0 && this.state.empty >= 2 && !this.state.justSurfed) { const beforeHeight = document.documentElement.scrollHeight; const beforeCount = this.detector.findFollowableButtons().length; const loaded = await this.triggerDynamicLoading(); if (loaded) { await Utils.sleep(500); const afterCount = this.detector.findFollowableButtons().length; const afterHeight = document.documentElement.scrollHeight; if (afterCount > beforeCount) { this.state.empty = 0; this.ui.updateAction(`새 버튼 ${afterCount}개 발견`); } else { this.state.empty++; this.ui.updateAction(`새 버튼 없음 (미탐지:${this.state.empty})`); const nearBottom = (window.innerHeight + window.scrollY) >= (document.documentElement.scrollHeight - Math.max(100, Math.floor(window.innerHeight * 0.1))); const noHeightChange = afterHeight === beforeHeight; if (this.state.currentPage === 'list' && !this.state.justSurfed && (nearBottom || noHeightChange)) { this.ui.updateAction('페이지 끝 감지 - 파도타기 진행'); await Utils.sleep(300); const success = await this.surfNextProfile(); if (success) { this.state.empty = 0; this.state.dynamicLoads = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; return 0; } } } } return 0; } if (!this.state.justSurfed) { this.state.empty = followCount ? 0 : this.state.empty + 1; } return followCount; } async surfNextProfile() { if (!this.canPerform('surf')) { return false; } this.ui.updateAction('파도타기 준비중...'); await this.ensureMoreCandidates(); let candidates = this.detector.findSurfableProfiles(); if (candidates.length === 0) { await this.ensureMoreCandidates(); candidates = this.detector.findSurfableProfiles(); } if (candidates.length === 0) { this.ui.updateAction('파도타기할 프로필 없음'); return false; } const candidate = candidates[Math.floor(Math.random() * candidates.length)]; this.state.totalSurf++; this.ui.updateAction(`파도타기: @${candidate.id}`); Utils.scrollToCenter(candidate.link); candidate.link.click(); this.state.empty = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; this.state.setJustSurfed(); await Utils.sleep(2000); this.state.dynamicLoads++; this.detector.gotoFollowerTab(); await Utils.sleep(1000); if (this.context?.config.scrollToTopAfterAction) { scrollTo(0, 0); } return true; } async followViaGraphQL(profileId, clipId) { console.log('🚀 팔로우 API 호출:', { profileId, clipId }); const result = await Utils.followViaGraphQL(profileId, clipId); console.log(result ? '✅ 팔로우 성공' : '❌ 팔로우 실패'); return result; } } class AutoScroller { constructor(state, actions) { this.state = state; this.actions = actions; this.lastHeight = 0; this.stuckCount = 0; this.interval = null; } start() { this.interval = setInterval(() => { this.handleScroll(); }, 1800); } handleScroll() { if (!this.state.run) return; if (!this.actions.canPerform('scroll')) return; const pageType = new PageDetector(this.state).detectPageType(); if (pageType === 'profile') return; const currentY = window.scrollY; if (Math.abs(currentY - this.state.lastScrollY) < 10) { this.state.stableScrollCount++; if (this.state.stableScrollCount >= 3) { scrollBy(0, Math.floor(innerHeight * 0.3)); this.state.stableScrollCount = 0; } } else { this.state.stableScrollCount = 0; } this.state.lastScrollY = currentY; const currentHeight = document.documentElement.scrollHeight; if (currentHeight === this.lastHeight) { this.stuckCount++; } else { this.stuckCount = 0; this.lastHeight = currentHeight; } if (this.stuckCount > 10) { this.handleStuckScroll(); } } async handleStuckScroll() { console.log('스크롤 막힘 감지 - 파도타기 시도중...'); const success = await this.actions.surfNextProfile(); if (success) { this.stuckCount = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; } else { this.stuckCount = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; } } stop() { if (this.interval) { clearInterval(this.interval); this.interval = null; } } } class StartMenu { constructor() { this.ui = null; this.onSelect = null; } show(onSelect) { this.onSelect = onSelect; this.createMenu(); } createMenu() { const menu = document.createElement('div'); menu.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2147483647; background: rgba(14,14,16,.95); backdrop-filter: blur(10px); color: #fff; padding: 30px; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.5); font: 14px/1.5 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; text-align: center; width: 320px; `; menu.innerHTML = ` <div style="margin-bottom: 20px;"> <h2 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 700; color: #fff;"> 🌊 Clip Follow Surfer </h2> <p style="margin: 0; font-size: 12px; opacity: 0.7; color: #9ccfff;"> 수행할 기능을 선택해주세요 </p> </div> <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px;"> <button id="followSurfBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); "> 🏄‍♂️ 팔로우 파도타기 시작 </button> <button id="excelExportBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); "> 📊 팔로우 현황 엑셀 출력 </button> <button id="unfollowBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #f59e0b, #d97706); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); "> 🗑️ 나만 팔로우 제거 (뒷삭 관리) </button> <button id="refollowBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); "> 🔄 다시 팔로우 하기 (끌어올리기) </button> <button id="cancelBtn" style=" padding: 10px 20px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: transparent; color: rgba(255,255,255,0.7); font-weight: 500; cursor: pointer; font-size: 12px; transition: all 0.2s ease; margin-top: 8px; "> 취소 </button> </div> <div style="border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(menu); this.ui = menu; const buttons = menu.querySelectorAll('button'); buttons.forEach(btn => { btn.onmouseenter = () => { if (btn.id !== 'cancelBtn') { btn.style.transform = 'translateY(-2px)'; btn.style.filter = 'brightness(1.1)'; } else { btn.style.background = 'rgba(255,255,255,0.1)'; } }; btn.onmouseleave = () => { btn.style.transform = 'translateY(0)'; btn.style.filter = 'brightness(1)'; if (btn.id === 'cancelBtn') { btn.style.background = 'transparent'; } }; }); menu.querySelector('#followSurfBtn').onclick = () => this.selectOption('followSurf'); menu.querySelector('#excelExportBtn').onclick = () => this.selectOption('excelExport'); menu.querySelector('#unfollowBtn').onclick = () => this.selectOption('unfollowCleanup'); menu.querySelector('#refollowBtn').onclick = () => this.selectOption('refollowBoost'); menu.querySelector('#cancelBtn').onclick = () => this.selectOption('cancel'); } selectOption(option) { this.destroy(); if (this.onSelect) { this.onSelect(option); } } destroy() { if (this.ui) { this.ui.remove(); this.ui = null; } } } class ClipFollowSurfer { constructor() { this.context = new FeatureContext(new FollowSurfConfig()); this.context.activate(); this.state = new BotState(this.context); this.ui = new BotUI(this.state); this.detector = new PageDetector(this.state); this.actions = new BotActions(this.context, this.ui, this.detector); this.scroller = new AutoScroller(this.state, this.actions); this.mainLoop = null; this.uiUpdater = null; this.mutationObserver = null; this.justNavigated = false; this.beforeUnloadHandler = null; this.visibilityHandler = null; this.initialize(); } initialize() { this.setupMutationObserver(); this.startMainLoop(); this.startUIUpdater(); this.scroller.start(); const originalDestroy = this.ui.destroy.bind(this.ui); this.ui.destroy = () => { this.cleanup(); originalDestroy(); }; this.beforeUnloadHandler = () => { console.log('[ClipFollowSurfer] 페이지 이탈 감지 - 정리 시작'); this.cleanup(); }; window.addEventListener('beforeunload', this.beforeUnloadHandler); this.visibilityHandler = () => { if (document.hidden) { console.log('[ClipFollowSurfer] 페이지 숨김 - 리소스 일시 중지'); if (this.mutationObserver) { this.mutationObserver.disconnect(); } } else { console.log('[ClipFollowSurfer] 페이지 표시 - 리소스 재시작'); if (this.mutationObserver && !this.state.run) { this.setupMutationObserver(); } } }; document.addEventListener('visibilitychange', this.visibilityHandler); } setupMutationObserver() { this.mutationObserver = new MutationObserver(() => { if (this.justNavigated) return; this.detector.detectPageType(); const profileElements = Utils.queryAll('[class*="UIProfileInfo"],[class*="UIProfileHeader"]'); if (profileElements.length > 0) { setTimeout(() => this.detector.gotoFollowerTab(), 500); } }); this.mutationObserver.observe(document.documentElement, { childList: true, subtree: true }); } startMainLoop() { this.mainLoop = setInterval(async () => { await this.executeMainLoop(); }, 1000); } async executeMainLoop() { if (!this.state.run) return; const pageType = this.detector.detectPageType(); if (pageType !== 'profile') { const followedCount = await this.actions.followAllViaGraphQL(); if (followedCount > 0) { await Utils.sleep(1500); } } if (this.state.totalSurf >= 100) { this.ui.setPausedState(UIConstants.LABELS.done); return; } if (this.actions.canPerform('surf') && this.shouldSurf(pageType)) { this.ui.updateAction('파도타기 시작...'); const success = await this.actions.surfNextProfile(); if (success) { this.justNavigated = true; setTimeout(() => { this.justNavigated = false; }, 3000); } } } shouldSurf(pageType) { return this.state.empty >= 5 && pageType === 'list' && !this.state.justSurfed; } startUIUpdater() { this.uiUpdater = setInterval(() => { this.ui.updateCounts(); }, 1000); } cleanup() { try { console.log('[ClipFollowSurfer] 정리 시작...'); if (this.context) { this.context.deactivate(); this.context = null; } if (this.mainLoop) { clearInterval(this.mainLoop); this.mainLoop = null; } if (this.uiUpdater) { clearInterval(this.uiUpdater); this.uiUpdater = null; } if (this.mutationObserver) { this.mutationObserver.disconnect(); this.mutationObserver = null; } if (this.scroller) { this.scroller.stop(); } if (this.beforeUnloadHandler) { window.removeEventListener('beforeunload', this.beforeUnloadHandler); this.beforeUnloadHandler = null; } if (this.visibilityHandler) { document.removeEventListener('visibilitychange', this.visibilityHandler); this.visibilityHandler = null; } console.log('[ClipFollowSurfer] 정리 완료'); } catch (error) { console.warn('[ClipFollowSurfer] Cleanup error:', error); } } } class ExcelExporter { constructor() { this.context = new FeatureContext(new ExcelExportConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.cancelled = false; } async start() { if (!/clip\.naver\.com\/@/.test(location.href)) { alert('clip.naver.com 프로필 팔로워/팔로잉 탭에서 실행해주세요'); this.cleanup(); return; } this.createUI(); try { this.profileId = Utils.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileId를 입력해주세요:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.loadXLSX(); await this.exportToExcel(); } catch (error) { console.error('Excel export error:', error); this.updateStatus('⚠️ 오류: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #3b82f6; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">추출중</span> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">📥 준비 중...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="closeBtn" style="flex: 1 1 auto; width: 100%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; const closeBtn = ui.querySelector('#closeBtn'); Utils.setupCancelButton(closeBtn, this); Utils.addHoverEffects(closeBtn); } updateStatus(message) { Utils.updateStatus(this.ui, message); } async loadXLSX() { if (window.XLSX) return; return new Promise((resolve, reject) => { const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; script.onload = () => resolve(); script.onerror = () => reject(new Error('XLSX 라이브러리 로드 실패')); document.head.appendChild(script); }); } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } async exportToExcel() { const followers = await this.fetchFollowData('followers'); const followings = await this.fetchFollowData('followings'); const followersMap = new Map(followers.map(item => [(item.profileId || item.clipId), item])); const followingsMap = new Map(followings.map(item => [(item.profileId || item.clipId), item])); const allKeys = new Set([...followersMap.keys(), ...followingsMap.keys()]); const merged = []; for (const key of allKeys) { const follower = followersMap.get(key); const following = followingsMap.get(key); const base = follower || following || {}; const iFollow = !!following; const followsMe = !!follower; let relation = 'none'; if (iFollow && followsMe) relation = 'mutual'; else if (iFollow) relation = 'only_me_follow'; else if (followsMe) relation = 'only_them_follow'; merged.push({ profileId: base.profileId || '', clipId: base.clipId || '', nickname: base.nickname || '', profileImageUrl: base.profileImageUrl || '', description: base.description || '', i_follow: iFollow, follows_me: followsMe, relation: relation }); } const workbook = window.XLSX.utils.book_new(); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followers), 'Followers'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followings), 'Followings'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(merged), 'Merged'); const workbookOutput = window.XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }); const blob = new Blob([workbookOutput], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); const now = new Date(); const pad = n => String(n).padStart(2, '0'); link.download = `clip-follow-map-${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}.xlsx`; document.body.appendChild(link); link.click(); URL.revokeObjectURL(link.href); link.remove(); this.updateStatus(`✅ 완료! Followers ${followers.length}, Followings ${followings.length}`); setTimeout(() => this.cleanup(), 2500); } cleanup() { if (this.context) this.context.deactivate(); if (this.ui) { this.ui.remove(); this.ui = null; } window.__followBot = false; } } class UnfollowCleaner { constructor() { this.context = new FeatureContext(new UnfollowCleanConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.followingsData = []; this.followersData = []; this.followersMap = new Map(); this.onlyMeFollowList = []; this.processedCount = 0; this.cancelled = false; this.paused = false; this.checkCount = 0; this.unfollowCount = 0; } async start() { if (!/clip\.naver\.com\/@/.test(location.href)) { alert('clip.naver.com 프로필 페이지에서 실행해주세요'); this.cleanup(); return; } this.createUI(); try { this.profileId = Utils.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileId를 입력해주세요:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.collectAndAnalyzeData(); } catch (error) { console.error('Unfollow cleanup error:', error); this.updateStatus('⚠️ 오류: ' + error.message); } } async collectAndAnalyzeData() { try { this.updateStatus('📥 팔로워 데이터 수집 중...'); const followers = await this.fetchFollowData('followers'); this.updateStatus('📥 팔로잉 데이터 수집 중...'); const followings = await this.fetchFollowData('followings'); this.updateStatus('🔍 관계 분석 중...'); const analysis = this.analyzeFollowRelations(followers, followings); const onlyThemFollowAccounts = analysis.filter(account => account.relation === 'only_them_follow'); const onlyMeFollowAccounts = analysis.filter(account => account.relation === 'only_me_follow'); if (onlyThemFollowAccounts.length === 0 && onlyMeFollowAccounts.length === 0) { this.updateStatus('✅ 처리할 계정이 없습니다! (맞팔/뒷삭 모두 없음)'); setTimeout(() => this.cleanup(), 3000); return; } this.updateStatus(`🔄 맞팔 ${onlyThemFollowAccounts.length}개, 언팔로우 ${onlyMeFollowAccounts.length}개 준비 완료`); await Utils.sleep(1000); if (this.cancelled) { console.log('[UnfollowCleaner] 취소된 상태로 진행 UI 생성 건너뜀'); return; } this.createProgressUI(); let totalProcessed = 0; let totalSuccess = 0; if (onlyThemFollowAccounts.length > 0) { onlyThemFollowAccounts.reverse(); this.updateProgressStatus(`🤝 1단계: 맞팔 시작 (${onlyThemFollowAccounts.length}개)`); const followResults = await this.executeGraphQLFollows(onlyThemFollowAccounts); totalProcessed += followResults.processedCount; totalSuccess += followResults.successCount; if (!this.cancelled && onlyMeFollowAccounts.length > 0) { this.updateProgressStatus('1단계 완료! 2단계 준비 중...'); await Utils.sleep(1000); } } if (onlyMeFollowAccounts.length > 0 && !this.cancelled) { onlyMeFollowAccounts.reverse(); this.updateProgressStatus(`🗑️ 2단계: 뒷삭 관리 시작 (${onlyMeFollowAccounts.length}개)`); await this.executeGraphQLUnfollows(onlyMeFollowAccounts); } if (!this.cancelled) { const followCount = onlyThemFollowAccounts.length; const unfollowCount = onlyMeFollowAccounts.length; this.updateProgressStatus(`🎉 모든 작업 완료! 맞팔 ${followCount}개, 언팔로우 ${unfollowCount}개 처리됨`); } } catch (error) { console.error('Data collection error:', error); this.updateStatus('⚠️ 데이터 수집 오류: ' + error.message); } } analyzeFollowRelations(followers, followings) { const followersMap = new Map(followers.map(item => [(item.profileId || item.clipId), item])); const followingsMap = new Map(followings.map(item => [(item.profileId || item.clipId), item])); const allKeys = new Set([...followersMap.keys(), ...followingsMap.keys()]); const results = []; for (const key of allKeys) { const follower = followersMap.get(key); const following = followingsMap.get(key); const base = follower || following || {}; const iFollow = !!following; const followsMe = !!follower; let relation = 'none'; if (iFollow && followsMe) relation = 'mutual'; else if (iFollow) relation = 'only_me_follow'; else if (followsMe) relation = 'only_them_follow'; results.push({ profileId: base.profileId || '', clipId: base.clipId || '', nickname: base.nickname || '', profileImageUrl: base.profileImageUrl || '', description: base.description || '', i_follow: iFollow, follows_me: followsMe, relation: relation }); } return results; } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #f59e0b; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">언팔중</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px;"> 데이터 수집 중... </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">🔄 맞팔 + 뒷삭 관리 시작...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; this.setupInitialButtons(); } setupInitialButtons() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (!this.paused) { this.paused = true; this.setInitialButtonPausedState(); } else { this.paused = false; this.setInitialButtonRunningState(); } }); closeBtn.addEventListener('click', () => { this.cancelled = true; this.cleanup(); window.__followBot = false; }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); this.setupKeyboardShortcuts(); } setInitialButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '수집중'; badge.style.background = '#f59e0b'; } } setInitialButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '일시정지'; badge.style.background = '#f59e0b'; } this.updateStatus('⏸️ 일시정지됨 - Resume을 눌러 계속하세요'); } createProgressUI() { if (this.cancelled) { console.log('[UnfollowCleaner] 취소된 상태로 UI 생성 건너뜀'); return; } if (this.ui) { this.ui.remove(); } this.ui = Utils.createProgressUI( '🔄 맞팔 + 뒷삭 관리', '실행중', '#f59e0b', () => { if (!this.paused) { this.paused = true; this.setButtonPausedState(); } else { this.paused = false; this.setButtonRunningState(); } }, () => { console.log('[UnfollowCleaner] Close 버튼 클릭됨'); this.cancelled = true; this.cleanup(); window.__followBot = false; } ); this.setupKeyboardShortcuts(); } setupKeyboardShortcuts() { this.keydownHandler = (e) => { if (e.key === 'Escape') { const pauseBtn = this.ui.querySelector('#pauseBtn'); if (pauseBtn && pauseBtn.style.display !== 'none') { pauseBtn.click(); } } }; addEventListener('keydown', this.keydownHandler); } removeKeyboardShortcuts() { if (this.keydownHandler) { removeEventListener('keydown', this.keydownHandler); this.keydownHandler = null; } } setButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '언팔중'; badge.style.background = '#f59e0b'; } } setButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '일시정지'; badge.style.background = '#f59e0b'; } this.updateProgressStatus('⏸️ 일시정지됨 - Resume을 눌러 계속하세요'); } setButtonCompletedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.style.display = 'none'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = '닫기'; closeBtn.style.background = '#059669'; closeBtn.style.width = '100%'; closeBtn.onclick = () => { this.cleanup(); window.__followBot = false; }; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '완료'; badge.style.background = '#10b981'; } } async executeGraphQLUnfollows(accounts) { const totalCount = accounts.length; let processedCount = 0; let successCount = 0; const totalCountEl = this.ui.querySelector('#totalCount'); if (totalCountEl) totalCountEl.textContent = totalCount; this.updateProgressStatus('언팔로우 시작...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`언팔로우: ${account.nickname || account.clipId}`); const success = await this.unfollowViaGraphQL(account.profileId, account.clipId); if (success) { successCount++; } else { this.updateProgressStatus(`❌ 언팔로우 실패: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Unfollow error for', account.clipId, error); this.updateProgressStatus(`❌ 오류: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = 300 + Math.random() * 100; await Utils.sleep(delay); } } if (this.cancelled) { this.updateProgressStatus(`🛑 중단됨 - 완료: ${successCount}/${processedCount}`); } else { this.updateProgressStatus(`✅ 모든 작업 완료! 성공: ${successCount}/${totalCount}`); this.setButtonCompletedState(); } } async unfollowViaGraphQL(profileId, clipId) { return await Utils.unfollowViaGraphQL(profileId, clipId); } async followViaGraphQL(profileId, clipId) { return await Utils.followViaGraphQL(profileId, clipId); } async executeGraphQLFollows(accounts) { const totalCount = accounts.length; let processedCount = 0; let successCount = 0; if (totalCount === 0) { return { processedCount: 0, successCount: 0 }; } this.updateProgressStatus('맞팔 시작...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`맞팔: ${account.nickname || account.clipId}`); const success = await this.followViaGraphQL(account.profileId, account.clipId); if (success) { successCount++; this.updateProgressStatus(`✅ 맞팔 완료: ${account.nickname || account.clipId}`); } else { this.updateProgressStatus(`❌ 맞팔 실패: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Follow error for', account.clipId, error); this.updateProgressStatus(`❌ 오류: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = 300 + Math.random() * 100; await Utils.sleep(delay); } } return { processedCount, successCount }; } updateProgressStatus(message) { const statusEl = this.ui?.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } updateStatus(message) { Utils.updateStatus(this.ui, message); } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } async cleanupOldDOMElements() { try { const currentScrollY = window.scrollY; const windowHeight = window.innerHeight; const cleanupThreshold = windowHeight * 3; const followingItems = Utils.queryAll('li[class*="UIProfileListItem"]'); let removedCount = 0; for (const item of followingItems) { const rect = item.getBoundingClientRect(); const itemTopY = currentScrollY + rect.top; if (itemTopY < (currentScrollY - cleanupThreshold)) { try { item.remove(); removedCount++; } catch (e) { } } } if (window.gc && typeof window.gc === 'function') { window.gc(); } console.log(`DOM 정리 완료: ${removedCount}개 요소 제거`); return removedCount; } catch (error) { console.warn('DOM 정리 중 오류:', error); return 0; } } async detectPageLoadingFinished(currentHeight, lastHeight, currentButtonCount, lastButtonCount, stableHeightCount, noNewContentCount) { let newStableHeightCount = (currentHeight === lastHeight) ? stableHeightCount + 1 : 0; let newNoNewContentCount = (currentButtonCount === lastButtonCount) ? noNewContentCount + 1 : 0; const isAtBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - 100); const hasMoreButton = Utils.queryAll('button, div').some(el => { const text = el.textContent || ''; return /더.*보기|더.*로드|loading|로딩/i.test(text); }); if (newStableHeightCount >= 8 && newNoNewContentCount >= 5) { this.updateStatus('📄 페이지 끝 확인 중... 잠시만 기다려주세요.'); await Utils.sleep(3000); const finalHeight = document.documentElement.scrollHeight; const finalButtons = this.findFollowingButtonsOnFollowingPage(); if (finalHeight === currentHeight && finalButtons.length === currentButtonCount) { return { finished: true, reason: "모든 동적 로딩 완료", stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } } if (isAtBottom && newStableHeightCount >= 5) { this.updateStatus('📄 페이지 하단 도달 확인 중...'); await Utils.sleep(2000); const finalHeight = document.documentElement.scrollHeight; if (finalHeight === currentHeight) { return { finished: true, reason: "스크롤 종료.", stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } } return { finished: false, stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } async triggerDynamicLoadingForUnfollow() { this.updateStatus('🌊 동적 로딩 중...'); window.scrollBy(0, window.innerHeight * 1.5); await Utils.sleep(200); window.scrollBy(0, -window.innerHeight * 0.3); await Utils.sleep(150); window.scrollBy(0, window.innerHeight * 0.8); await Utils.sleep(300); const randomMove = (Math.random() - 0.5) * window.innerHeight * 0.2; window.scrollBy(0, randomMove); await Utils.sleep(150); this.updateStatus('✅ 동적 로딩 완료'); return true; } async collectAllFollowersData() { this.updateStatus('📥 전체 팔로워 데이터 수집 중...'); const endpoint = '/api/graphql'; const query = `query Q($after:String,$first:Int,$input:FollowersInput!){followers(input:$input,after:$after,first:$first){edges{node{profileId clipId nickname profileImageUrl description follow id}}pageInfo{hasNextPage endCursor totalCount}}}`; let cursor = null; const results = []; for (let i = 0; i < 9999; i++) { if (this.cancelled) return; this.updateStatus(`📥 팔로워 ${results.length}개 수집 중...`); const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 50, input: { profileId: this.profileId } } }) }); const data = await response.json(); const root = data.data.followers; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) continue; results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; nextCursor = root.nextCursor; await Utils.sleep(350 + Math.random() * 250); } this.followersMap = new Map(); for (const follower of results) { if (follower.clipId) { this.followersMap.set(follower.clipId, follower); } else if (follower.profileId) { this.followersMap.set(follower.profileId, follower); } } this.updateStatus(`✅ 전체 팔로워 ${results.length}명 수집 완료`); await Utils.sleep(1000); } cleanup() { this.removeKeyboardShortcuts(); this.cancelled = true; if (this.context) this.context.deactivate(); if (this.ui) { this.ui.remove(); this.ui = null; } window.__followBot = false; console.log('[UnfollowCleaner] cleanup 완료'); } } class RefollowBooster { constructor() { this.context = new FeatureContext(new UnfollowCleanConfig()); this.context.activate(); this.ui = null; this.profileId = null; this.cancelled = false; this.paused = false; } async start() { try { if (!location.href.includes('clip.naver.com/@')) { alert('클립 프로필 페이지에서만 사용 가능합니다.'); return; } this.profileId = Utils.extractProfileId(); if (!this.profileId) { alert('프로필 ID를 찾을 수 없습니다.'); return; } console.log('[RefollowBooster] 끌어올리기 시작:', this.profileId); this.createUI(); await this.collectAndBoost(); } catch (error) { console.error('RefollowBooster start error:', error); this.updateStatus('⚠️ 오류 발생: ' + error.message); setTimeout(() => this.cleanup(), 3000); } } async collectAndBoost() { try { this.updateStatus('📥 팔로잉 목록 수집 중...'); const followings = await this.fetchFollowData('followings'); if (this.cancelled) return; if (followings.length === 0) { this.updateStatus('✅ 팔로잉하는 계정이 없습니다!'); setTimeout(() => this.cleanup(), 3000); return; } this.updateStatus(`🔄 총 ${followings.length}개 계정 끌어올리기 준비 완료`); await Utils.sleep(1000); this.createProgressUI(); followings.reverse(); await this.executeRefollowBoost(followings); } catch (error) { console.error('Data collection error:', error); this.updateStatus('⚠️ 데이터 수집 오류: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = Utils.getFixedUIStyles(); ui.innerHTML = ` ${Utils.getServiceHeaderHTML()} <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #8b5cf6; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">끌올중</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px;"> 데이터 수집 중... </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">🔄 끌어올리기 시작...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="pauseBtn" style="flex: 1 1 auto; width: 80%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #ef4444; color: #fff;">Stop</button> <button id="closeBtn" style="flex: 1 1 auto; width: 38%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff; display: none;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; this.setupInitialButtons(); } setupInitialButtons() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); pauseBtn.addEventListener('click', () => { if (!this.paused) { this.paused = true; this.setInitialButtonPausedState(); } else { this.paused = false; this.setInitialButtonRunningState(); } }); closeBtn.addEventListener('click', () => { this.cancelled = true; this.cleanup(); window.__followBot = false; }); Utils.addHoverEffects(pauseBtn); Utils.addHoverEffects(closeBtn); this.setupKeyboardShortcuts(); } setInitialButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '끌올중'; badge.style.background = '#8b5cf6'; } } setInitialButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '일시정지'; badge.style.background = '#8b5cf6'; } this.updateStatus('⏸️ 일시정지됨 - Resume을 눌러 계속하세요'); } createProgressUI() { if (this.cancelled) { console.log('[RefollowBooster] 취소된 상태로 UI 생성 건너뜀'); return; } if (this.ui) { this.ui.remove(); } this.ui = Utils.createProgressUI( 'Clip Follow Surfer', '끌올중', '#8b5cf6', () => { if (!this.paused) { this.paused = true; this.setButtonPausedState(); } else { this.paused = false; this.setButtonRunningState(); } }, () => { console.log('[RefollowBooster] Close 버튼 클릭됨'); this.cancelled = true; this.cleanup(); window.__followBot = false; } ); } setButtonRunningState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Stop'; pauseBtn.style.background = '#ef4444'; pauseBtn.style.width = '80%'; } if (closeBtn) { closeBtn.style.display = 'none'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '끌올중'; badge.style.background = '#8b5cf6'; } } setButtonPausedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.textContent = 'Resume'; pauseBtn.style.background = '#3b82f6'; pauseBtn.style.width = '38%'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.textContent = 'Close'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '일시정지'; badge.style.background = '#f59e0b'; } this.updateProgressStatus('⏸️ 일시정지됨 - Resume을 눌러 계속하세요'); } setButtonCompletedState() { const pauseBtn = this.ui.querySelector('#pauseBtn'); const closeBtn = this.ui.querySelector('#closeBtn'); if (pauseBtn) { pauseBtn.style.display = 'none'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.style.width = '100%'; closeBtn.textContent = '닫기'; closeBtn.style.background = '#8b5cf6'; } const badge = this.ui.querySelector('#badge'); if (badge) { badge.textContent = '완료'; badge.style.background = '#8b5cf6'; } } async fetchFollowData(type) { return await Utils.fetchFollowData( this.profileId, type, (message) => this.updateStatus(message), () => this.cancelled ); } async executeRefollowBoost(accounts) { let processedCount = 0; let successCount = 0; const totalCount = accounts.length; const totalCountEl = this.ui.querySelector('#totalCount'); if (totalCountEl) totalCountEl.textContent = totalCount; this.updateProgressStatus('끌어올리기 시작...'); for (let i = 0; i < accounts.length && !this.cancelled; i++) { while (this.paused && !this.cancelled) { await Utils.sleep(500); } if (this.cancelled) break; const account = accounts[i]; try { this.updateProgressStatus(`끌어올리기: ${account.nickname || account.clipId}`); const unfollowSuccess = await this.unfollowViaGraphQL(account.profileId, account.clipId); if (unfollowSuccess) { await Utils.sleep(200 + Math.random() * 100); const refollowSuccess = await this.followViaGraphQL(account.profileId, account.clipId); if (refollowSuccess) { successCount++; this.updateProgressStatus(`✅ 끌어올리기 완료: ${account.nickname || account.clipId}`); } else { this.updateProgressStatus(`❌ 재팔로우 실패: ${account.nickname || account.clipId}`); } } else { this.updateProgressStatus(`❌ 언팔로우 실패: ${account.nickname || account.clipId}`); } } catch (error) { console.error('Refollow boost error for', account.clipId, error); this.updateProgressStatus(`❌ 오류: ${account.nickname || account.clipId}`); } processedCount++; const processedCountEl = this.ui.querySelector('#processedCount'); const successCountEl = this.ui.querySelector('#successCount'); if (processedCountEl) processedCountEl.textContent = processedCount; if (successCountEl) successCountEl.textContent = successCount; if (i < accounts.length - 1 && !this.cancelled) { const delay = 500 + Math.random() * 300; await Utils.sleep(delay); } } if (this.cancelled) { this.updateProgressStatus('❌ 끌어올리기가 중단되었습니다'); } else { this.updateProgressStatus(`🎉 끌어올리기 완료! 총 ${successCount}개 계정 처리됨`); this.setButtonCompletedState(); } } async unfollowViaGraphQL(profileId, clipId) { return await Utils.unfollowViaGraphQL(profileId, clipId); } async followViaGraphQL(profileId, clipId) { return await Utils.followViaGraphQL(profileId, clipId); } updateStatus(message) { if (this.ui) { const statusEl = this.ui.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } } updateProgressStatus(message) { if (this.ui) { const statusEl = this.ui.querySelector('#statusText'); if (statusEl) { statusEl.textContent = message; } } } setupKeyboardShortcuts() { this.keyboardHandler = (e) => { if (e.key === 'Escape') { e.preventDefault(); const pauseBtn = this.ui?.querySelector('#pauseBtn'); if (pauseBtn) { pauseBtn.click(); } } }; document.addEventListener('keydown', this.keyboardHandler); } removeKeyboardShortcuts() { if (this.keyboardHandler) { document.removeEventListener('keydown', this.keyboardHandler); this.keyboardHandler = null; } } cleanup() { this.cancelled = true; this.removeKeyboardShortcuts(); if (this.ui) { this.ui.remove(); this.ui = null; } if (this.context) this.context.deactivate(); window.__followBot = false; console.log('[RefollowBooster] cleanup 완료'); } } class App { static start() { const menu = new StartMenu(); menu.show((option) => { switch (option) { case 'followSurf': new ClipFollowSurfer(); break; case 'excelExport': new ExcelExporter().start(); break; case 'unfollowCleanup': new UnfollowCleaner().start(); break; case 'refollowBoost': new RefollowBooster().start(); break; case 'cancel': window.__followBot = false; break; } }); } } App.start(); })();
