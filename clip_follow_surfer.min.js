const VERSION = '2025.08.19 00:00:00'; (() => { 'use strict'; if (window.__followBot) { alert('Already running'); return; } window.__followBot = true; class BotState { constructor() { this.run = true; this.delay = 650; this.scrollDelay = 2000; this.empty = 0; this.totalFollow = 0; this.totalSurf = 0; this.clickedButtons = new Set(); this.followedAccounts = new Set(); this.currentPage = 'unknown'; this.lastScrollY = 0; this.stableScrollCount = 0; this.dynamicLoads = 0; this.justSurfed = false; } reset() { this.clickedButtons.clear(); this.followedAccounts.clear(); this.empty = 0; this.stableScrollCount = 0; } setJustSurfed() { this.justSurfed = true; setTimeout(() => { this.justSurfed = false; }, 3000); } } class UIConstants { static COLORS = { red: '#ef4444', redDim: '#b91c1c', blue: '#3b82f6', green: '#10b981', orange: '#f59e0b', bg: 'rgba(14,14,16,.88)', cardShadow: '0 8px 30px rgba(0,0,0,.35)' }; static LABELS = { follow: '팔로우', surf: '파도타기', paused: '일시정지', done: '100회 완료' }; } class BotUI { constructor(state) { this.state = state; this.elements = {}; this.createUI(); this.bindEvents(); } createUI() { const ui = document.createElement('div'); ui.style.cssText = this.getMainUIStyles(); ui.innerHTML = this.getUITemplate(); document.body.appendChild(ui); this.ui = ui; this.cacheElements(); this.setupButtons(); } getMainUIStyles() { return ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: ${UIConstants.COLORS.bg}; backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: ${UIConstants.COLORS.cardShadow}; font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; } getUITemplate() { return ` <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.16); padding-bottom: 6px; font-size: 12px; font-weight: 600; text-align: center;"> 블라이, '상위노출' 분석 서비스 : <a href="https://blai.co.kr?invite=늑대왕" target="_blank" rel="noopener" style="color: #9ccfff; text-decoration: underline;">바로가기</a> </div> <div style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:4px"> <b style="font-size:13px">Clip Follow Surfer</b> <span id="badge" style="padding:2px 8px;border-radius:999px;background:#10b981;color:#052;font-weight:700;font-size:10px;letter-spacing:.25px"> 서핑중 </span> </div> <div id="stats" style="opacity:.95;font-size:11px;line-height:1.4"> 팔로우: <b id="followCount">0</b> | 파도타기: <b id="surfCount">0</b><br> 동적로딩: <span id="dynamicCount">0</span> | 연속미탐지: <span id="emptyCount">0</span> </div> <div id="currentAction" style="opacity:.8;font-size:10px;color:#9ccfff;margin:4px 0;min-height:15px;display:flex;align-items:center;justify-content:center"> 탐지중... </div> <div id="btnRow" style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;justify-content:center"> <button id="pauseBtn" style="flex:1 1 auto;width:80%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease"> Stop </button> <button id="closeBtn" style="flex:1 1 auto;width:38%;padding:6px 10px;border:0;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,.07) inset,0 2px 10px rgba(0,0,0,.25);transition:transform .08s ease,filter .15s ease,opacity .2s ease;display:none"> Close </button> </div> <div style="margin-top:10px;border-top:1px solid rgba(255,255,255,.16);padding-top:8px;font-size:10px;opacity:.7"> 버전 : ${VERSION} </div> `; } cacheElements() { this.elements = { stats: this.ui.querySelector('#stats'), pauseBtn: this.ui.querySelector('#pauseBtn'), closeBtn: this.ui.querySelector('#closeBtn'), badge: this.ui.querySelector('#badge'), action: this.ui.querySelector('#currentAction'), followCount: this.ui.querySelector('#followCount'), surfCount: this.ui.querySelector('#surfCount'), dynamicCount: this.ui.querySelector('#dynamicCount'), emptyCount: this.ui.querySelector('#emptyCount') }; } setupButtons() { this.addHoverEffects(this.elements.pauseBtn); this.addHoverEffects(this.elements.closeBtn); this.setRunningState(); } addHoverEffects(button) { button.onmouseenter = () => button.style.filter = 'brightness(1.06)'; button.onmouseleave = () => button.style.filter = 'none'; button.onmousedown = () => button.style.transform = 'scale(0.98)'; button.onmouseup = () => button.style.transform = 'scale(1)'; } setButtonColor(button, backgroundColor) { button.style.background = backgroundColor; button.style.color = '#fff'; } setRunningState() { this.state.run = true; this.elements.pauseBtn.textContent = 'Stop'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.red); this.elements.pauseBtn.style.width = '80%'; this.elements.closeBtn.style.display = 'none'; this.elements.badge.textContent = '서핑중'; this.elements.badge.style.background = UIConstants.COLORS.green; this.updateAction('동작중...'); } setPausedState(reason = UIConstants.LABELS.paused) { this.state.run = false; this.elements.pauseBtn.textContent = 'Resume'; this.setButtonColor(this.elements.pauseBtn, UIConstants.COLORS.blue); this.elements.pauseBtn.style.width = '38%'; this.elements.closeBtn.style.display = 'inline-block'; this.setButtonColor(this.elements.closeBtn, UIConstants.COLORS.redDim); this.elements.badge.textContent = '휴식중'; this.elements.badge.style.background = UIConstants.COLORS.orange; this.updateAction(reason); } updateAction(action) { if (action) { this.elements.action.textContent = action; } } updateCounts() { this.elements.followCount.textContent = this.state.totalFollow; this.elements.surfCount.textContent = this.state.totalSurf; this.elements.dynamicCount.textContent = this.state.dynamicLoads; this.elements.emptyCount.textContent = this.state.empty; } bindEvents() { this.elements.pauseBtn.onclick = () => { if (this.state.run) { this.setPausedState(); } else { this.setRunningState(); } }; this.elements.closeBtn.onclick = () => { this.destroy(); }; addEventListener('keydown', (e) => { if (e.key === 'Escape') { this.elements.pauseBtn.click(); } }); } destroy() { window.__followBot = false; try { this.ui.remove(); } catch (error) { console.warn('UI cleanup error:', error); } } } class Utils { static queryAll(selector, searchArea = document) { return Array.from(searchArea.querySelectorAll(selector)); } static normalizeText(element) { return (element.textContent || '').replace(/\s+/g, '').trim(); } static isVisible(element) { const rect = element.getBoundingClientRect(); return rect.bottom >= 0 && rect.top <= innerHeight + 400; } static sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } static scrollToCenter(element) { element.scrollIntoView({ block: 'center', behavior: 'smooth' }); } static simulateMouseEvents(element) { const events = ['mouseover', 'mousedown', 'mouseup']; events.forEach(eventType => { element.dispatchEvent(new MouseEvent(eventType, { bubbles: true })); }); } } class PageDetector { constructor(state) { this.state = state; } detectPageType() { if (location.pathname.includes('/@')) { const profileElements = Utils.queryAll('[class*="UIProfileInfo"],[class*="UIProfileHeader"]'); if (profileElements.length > 0) { this.state.currentPage = 'profile'; return 'profile'; } } const listElements = Utils.queryAll('li[class*="UIProfileListItem"]'); const followSectionElements = Utils.queryAll('[class*="MyFollowProfileSection"]'); if (listElements.length > 0 || followSectionElements.length > 0) { this.state.currentPage = 'list'; return 'list'; } this.state.currentPage = 'unknown'; return 'unknown'; } isFollowingButton(button) { const text = Utils.normalizeText(button); return /팔로잉|Following|언팔로우/.test(text) || button.getAttribute('aria-pressed') === 'true'; } findFollowableButtons() { const buttonSelectors = 'button,a,[role="button"]'; const buttons = Utils.queryAll(buttonSelectors); return buttons.filter(button => { const text = Utils.normalizeText(button); const isFollowBtn = /팔로우/.test(text) && !/팔로잉|팔로우중|Following|언팔로우/i.test(text) && !this.isFollowingButton(button); const isEnabled = !button.closest('[disabled],[aria-disabled="true"]') && button.getAttribute('aria-pressed') !== 'true'; const accountId = this.extractAccountIdFromButton(button); const notFollowed = !this.state.followedAccounts.has(accountId); const buttonId = this.ensureButtonId(button); const notClicked = !this.state.clickedButtons.has(buttonId); return isFollowBtn && isEnabled && notFollowed && notClicked; }); } findSurfableProfiles() { const candidates = []; const listSelector = 'li[class*="UIProfileListItem_list_item"],li[class^="UIProfileListItem_list_item"]'; const listItems = Utils.queryAll(listSelector); for (const item of listItems) { const link = item.querySelector('a[href^="/@"],a[href*="/@"],a[role="button"],[role="button"]'); const id = this.extractIdFromElement(link || item); if (id) { candidates.push({ id, link: link || item, element: item }); } } const directLinks = Utils.queryAll('a[href^="/@"],a[href*="/@"]') .filter(link => Utils.isVisible(link)); for (const link of directLinks) { const id = this.extractIdFromElement(link); if (id && !candidates.find(candidate => candidate.id === id)) { candidates.push({ id, link, element: link }); } } return candidates.filter(candidate => Utils.isVisible(candidate.element)); } ensureButtonId(button) { if (!button.dataset.buttonId) { button.dataset.buttonId = 'btn_' + Math.random().toString(36).substr(2, 9); } return button.dataset.buttonId; } extractAccountIdFromButton(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return accountId.replace(/^@/, ''); } } const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) { return decodeURIComponent(match[1]); } } } return this.extractIdFromElement(button) || 'unknown_' + Math.random().toString(36).substr(2, 9); } extractAccountName(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return '@' + accountId; } } const nameElement = parent.querySelector('[class*="UIProfileListItem_tit_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (nameElement) { const accountName = nameElement.textContent?.trim(); if (accountName && accountName.length > 0 && !accountName.includes('팔로우')) { return accountName.slice(0, 15); } } const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) { return '@' + decodeURIComponent(match[1]); } } } const siblings = Array.from(button.parentElement?.children || []); for (const sibling of siblings) { if (sibling !== button) { const text = sibling.textContent?.trim(); if (text && text.length > 2 && !text.includes('팔로우') && !/^\d+$/.test(text)) { return text.slice(0, 15); } } } return '알수없음'; } extractIdFromElement(element) { if (!element) return null; const href = element.getAttribute && element.getAttribute('href'); if (href) { const match = href.match(/\/@([^/?#]+)/); if (match) { return decodeURIComponent(match[1]); } } const text = (element.innerText || element.textContent || '').trim(); const textMatch = text.match(/@([A-Za-z0-9._-]{3,32})/); if (textMatch) { return textMatch[1]; } if (element.querySelector) { const idNode = element.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIProfileListItem_tit_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idNode) { const nodeText = (idNode.innerText || '').trim().replace(/^@/, '').replace(/\s+/g, ''); if (nodeText && /^[A-Za-z0-9._-]{3,32}$/.test(nodeText)) { return nodeText; } } } return null; } gotoFollowerTab() { const followerTab = Utils.queryAll('a,button,[role="button"]') .find(element => /팔로워/i.test(element.textContent || '')); if (followerTab) { followerTab.click(); return true; } return false; } } class BotActions { constructor(state, ui, detector) { this.state = state; this.ui = ui; this.detector = detector; } async ensureMoreCandidates() { const listSelector = 'li[class*="UIProfileListItem_list_item"],li[class^="UIProfileListItem_list_item"]'; const visibleItems = Utils.queryAll(listSelector).filter(Utils.isVisible); if (visibleItems.length <= 3) { this.ui.updateAction('더 많은 후보 로딩중...'); scrollBy(0, window.innerHeight * 0.8); await Utils.sleep(500); this.state.dynamicLoads++; } } async triggerDynamicLoading() { this.ui.updateAction('동적 로딩 중...'); scrollBy(0, window.innerHeight * 1.5); await Utils.sleep(800); this.state.dynamicLoads++; this.ui.updateAction('동적 로딩 완료'); return true; } async clickRecommendButtons() { let clickCount = 0; const recommendSelector = '[class*="MyFollowProfileSection_recommend_area"] button,[class*="MyFollowProfileSection_recommend_area"] a,[class*="MyFollowProfileSection_recommend_area"] [role="button"]'; const recommendButtons = Utils.queryAll(recommendSelector).filter(button => { const text = Utils.normalizeText(button); const isFollowBtn = /팔로우/.test(text) && !/팔로잉|팔로우중|Following|언팔로우/i.test(text) && !this.detector.isFollowingButton(button); const isEnabled = !button.closest('[disabled],[aria-disabled="true"]') && button.getAttribute('aria-pressed') !== 'true'; const accountId = this.detector.extractAccountIdFromButton(button); const notFollowed = !this.state.followedAccounts.has(accountId); const buttonId = this.detector.ensureButtonId(button); const notClicked = !this.state.clickedButtons.has(buttonId); return isFollowBtn && isEnabled && notFollowed && notClicked; }); this.ui.updateAction(`창작자 추천: ${recommendButtons.length}개`); for (const button of recommendButtons) { if (this.detector.isFollowingButton(button)) continue; const accountId = this.detector.extractAccountIdFromButton(button); if (this.state.followedAccounts.has(accountId)) continue; const buttonId = button.dataset.buttonId; if (this.state.clickedButtons.has(buttonId)) continue; this.state.followedAccounts.add(accountId); this.state.clickedButtons.add(buttonId); Utils.scrollToCenter(button); const isVisible = Utils.isVisible(button); await Utils.sleep(isVisible ? 300 : 800); const accountName = this.detector.extractAccountName(button); Utils.simulateMouseEvents(button); button.click(); clickCount++; this.state.totalFollow++; this.ui.updateAction(`추천 팔로우: ${accountName}${isVisible ? '' : '(스크롤됨)'}`); await Utils.sleep(this.state.delay); } return clickCount; } async clickAllFollows() { let clickCount = 0; const hasRecommendArea = Utils.queryAll('[class*="MyFollowProfileSection_recommend_area"]').length > 0; if (hasRecommendArea) { clickCount += await this.clickRecommendButtons(); } const followButtons = this.detector.findFollowableButtons(); this.ui.updateAction(`일반 팔로우: ${followButtons.length}개`); for (const button of followButtons) { if (this.detector.isFollowingButton(button)) continue; const accountId = this.detector.extractAccountIdFromButton(button); if (this.state.followedAccounts.has(accountId)) continue; const buttonId = button.dataset.buttonId; if (this.state.clickedButtons.has(buttonId)) continue; this.state.followedAccounts.add(accountId); this.state.clickedButtons.add(buttonId); Utils.scrollToCenter(button); const isVisible = Utils.isVisible(button); await Utils.sleep(isVisible ? 300 : 800); const accountName = this.detector.extractAccountName(button); Utils.simulateMouseEvents(button); button.click(); clickCount++; this.state.totalFollow++; this.ui.updateAction(`팔로우: ${accountName}${isVisible ? '' : '(스크롤됨)'}`); await Utils.sleep(this.state.delay); } if (clickCount === 0 && this.state.empty >= 2 && !this.state.justSurfed) { const beforeCount = this.detector.findFollowableButtons().length; const loaded = await this.triggerDynamicLoading(); if (loaded) { await Utils.sleep(500); const afterCount = this.detector.findFollowableButtons().length; if (afterCount > beforeCount) { this.state.empty = 0; this.ui.updateAction(`새 버튼 ${afterCount}개 발견`); } else { this.state.empty++; this.ui.updateAction(`새 버튼 없음 (미탐지:${this.state.empty})`); } } return 0; } if (!this.state.justSurfed) { this.state.empty = clickCount ? 0 : this.state.empty + 1; } return clickCount; } async surfNextProfile() { this.ui.updateAction('파도타기 준비중...'); await this.ensureMoreCandidates(); let candidates = this.detector.findSurfableProfiles(); if (candidates.length === 0) { await this.ensureMoreCandidates(); candidates = this.detector.findSurfableProfiles(); } if (candidates.length === 0) { this.ui.updateAction('파도타기할 프로필 없음'); return false; } const candidate = candidates[Math.floor(Math.random() * candidates.length)]; this.state.totalSurf++; this.ui.updateAction(`파도타기: @${candidate.id}`); Utils.scrollToCenter(candidate.link); candidate.link.click(); this.state.setJustSurfed(); await Utils.sleep(1000); this.state.dynamicLoads++; this.detector.gotoFollowerTab(); await Utils.sleep(500); if (!window.__unfollowMode) { scrollTo(0, 0); } return true; } } class AutoScroller { constructor(state, actions) { this.state = state; this.actions = actions; this.lastHeight = 0; this.stuckCount = 0; this.interval = null; } start() { this.interval = setInterval(() => { this.handleScroll(); }, 1800); } handleScroll() { if (!this.state.run) return; if (window.__unfollowMode) return; const pageType = new PageDetector(this.state).detectPageType(); if (pageType === 'profile') return; const currentY = window.scrollY; if (Math.abs(currentY - this.state.lastScrollY) < 10) { this.state.stableScrollCount++; if (this.state.stableScrollCount >= 3) { scrollBy(0, Math.floor(innerHeight * 0.3)); this.state.stableScrollCount = 0; } } else { this.state.stableScrollCount = 0; } this.state.lastScrollY = currentY; const currentHeight = document.documentElement.scrollHeight; if (currentHeight === this.lastHeight) { this.stuckCount++; } else { this.stuckCount = 0; this.lastHeight = currentHeight; } if (this.stuckCount > 10) { this.handleStuckScroll(); } } async handleStuckScroll() { console.log('스크롤 막힘 감지 - 파도타기 시도중...'); const success = await this.actions.surfNextProfile(); if (success) { this.stuckCount = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; } else { this.stuckCount = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; } } stop() { if (this.interval) { clearInterval(this.interval); this.interval = null; } } } class StartMenu { constructor() { this.ui = null; this.onSelect = null; } show(onSelect) { this.onSelect = onSelect; this.createMenu(); } createMenu() { const menu = document.createElement('div'); menu.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2147483647; background: rgba(14,14,16,.95); backdrop-filter: blur(10px); color: #fff; padding: 30px; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.5); font: 14px/1.5 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; text-align: center; width: 320px; `; menu.innerHTML = ` <div style="margin-bottom: 20px;"> <h2 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 700; color: #fff;"> 🌊 Clip Follow Surfer </h2> <p style="margin: 0; font-size: 12px; opacity: 0.7; color: #9ccfff;"> 수행할 기능을 선택해주세요 </p> </div> <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 16px;"> <button id="followSurfBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #10b981, #059669); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); "> 🏄‍♂️ 팔로우 파도타기 시작 </button> <button id="excelExportBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); "> 📊 팔로우 현황 엑셀 출력 </button> <button id="unfollowBtn" style=" padding: 14px 20px; border: 0; border-radius: 12px; background: linear-gradient(135deg, #f59e0b, #d97706); color: #fff; font-weight: 700; cursor: pointer; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); "> 🗑️ 나만 팔로우 제거 (뒷삭 관리) </button> <button id="cancelBtn" style=" padding: 10px 20px; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: transparent; color: rgba(255,255,255,0.7); font-weight: 500; cursor: pointer; font-size: 12px; transition: all 0.2s ease; margin-top: 8px; "> 취소 </button> </div> <div style="border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(menu); this.ui = menu; const buttons = menu.querySelectorAll('button'); buttons.forEach(btn => { btn.onmouseenter = () => { if (btn.id !== 'cancelBtn') { btn.style.transform = 'translateY(-2px)'; btn.style.filter = 'brightness(1.1)'; } else { btn.style.background = 'rgba(255,255,255,0.1)'; } }; btn.onmouseleave = () => { btn.style.transform = 'translateY(0)'; btn.style.filter = 'brightness(1)'; if (btn.id === 'cancelBtn') { btn.style.background = 'transparent'; } }; }); menu.querySelector('#followSurfBtn').onclick = () => this.selectOption('followSurf'); menu.querySelector('#excelExportBtn').onclick = () => this.selectOption('excelExport'); menu.querySelector('#unfollowBtn').onclick = () => this.selectOption('unfollowCleanup'); menu.querySelector('#cancelBtn').onclick = () => this.selectOption('cancel'); } selectOption(option) { this.destroy(); if (this.onSelect) { this.onSelect(option); } } destroy() { if (this.ui) { this.ui.remove(); this.ui = null; } } } class ExcelExporter { constructor() { this.ui = null; this.profileId = null; this.cancelled = false; } async start() { if (!/clip\.naver\.com\/@/.test(location.href)) { alert('clip.naver.com 프로필 팔로워/팔로잉 탭에서 실행해주세요'); this.cleanup(); return; } this.createUI(); try { this.profileId = this.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileId를 입력해주세요:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.loadXLSX(); await this.exportToExcel(); } catch (error) { console.error('Excel export error:', error); this.updateStatus('⚠️ 오류: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: rgba(14,14,16,.88); backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,.35); font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; ui.innerHTML = ` <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.16); padding-bottom: 6px; font-size: 12px; font-weight: 600; text-align: center;"> 블라이, '상위노출' 분석 서비스 : <a href="https://blai.co.kr?invite=늑대왕" target="_blank" rel="noopener" style="color: #9ccfff; text-decoration: underline;">바로가기</a> </div> <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #3b82f6; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">추출중</span> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">📥 준비 중...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="closeBtn" style="flex: 1 1 auto; width: 100%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; const closeBtn = ui.querySelector('#closeBtn'); closeBtn.onclick = () => { this.cancelled = true; this.updateStatus('❌ 사용자가 중단했습니다'); setTimeout(() => this.cleanup(), 1000); }; this.addHoverEffects(closeBtn); } addHoverEffects(button) { button.onmouseenter = () => button.style.filter = 'brightness(1.06)'; button.onmouseleave = () => button.style.filter = 'none'; button.onmousedown = () => button.style.transform = 'scale(0.98)'; button.onmouseup = () => button.style.transform = 'scale(1)'; } updateStatus(message) { if (this.ui) { const statusText = this.ui.querySelector('#statusText'); if (statusText) { statusText.textContent = message; } else { this.ui.textContent = message; } } } extractProfileId() { try { const html = document.documentElement.innerHTML; const matches = [...html.matchAll(/"profileId":"([A-Za-z0-9_\-]+)"/g)].map(x => x[1]); if (matches.length) { const frequency = matches.reduce((acc, val) => (acc[val] = (acc[val] || 0) + 1, acc), {}); return Object.entries(frequency).sort((a, b) => b[1] - a[1])[0][0]; } } catch (error) { console.warn('Profile ID extraction error:', error); } return null; } async loadXLSX() { if (window.XLSX) return; return new Promise((resolve, reject) => { const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; script.onload = () => resolve(); script.onerror = () => reject(new Error('XLSX 라이브러리 로드 실패')); document.head.appendChild(script); }); } async fetchFollowData(type) { const endpoint = '/api/graphql'; const queries = { followers: `query Q($after:String,$first:Int,$input:FollowersInput!){followers(input:$input,after:$after,first:$first){edges{node{profileId clipId nickname profileImageUrl description follow id}}pageInfo{hasNextPage endCursor totalCount}}}`, followings: `query Q($after:String,$first:Int,$input:FollowingsInput!){followings(input:$input,after:$after,first:$first){edges{node{profileId clipId nickname profileImageUrl description follow id}}pageInfo{hasNextPage endCursor totalCount}}}` }; const query = queries[type]; const key = type; let cursor = null; const results = []; for (let i = 0; i < 9999; i++) { this.updateStatus(`📥 ${type} ${results.length}개 수집 중...`); const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 50, input: { profileId: this.profileId } } }) }); const data = await response.json(); const root = data.data[key]; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) { continue; } results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; await Utils.sleep(350 + Math.random() * 250); } return results; } async exportToExcel() { const followers = await this.fetchFollowData('followers'); const followings = await this.fetchFollowData('followings'); const followersMap = new Map(followers.map(item => [(item.profileId || item.clipId), item])); const followingsMap = new Map(followings.map(item => [(item.profileId || item.clipId), item])); const allKeys = new Set([...followersMap.keys(), ...followingsMap.keys()]); const merged = []; for (const key of allKeys) { const follower = followersMap.get(key); const following = followingsMap.get(key); const base = follower || following || {}; const iFollow = !!following; const followsMe = !!follower; let relation = 'none'; if (iFollow && followsMe) relation = 'mutual'; else if (iFollow) relation = 'only_me_follow'; else if (followsMe) relation = 'only_them_follow'; merged.push({ profileId: base.profileId || '', clipId: base.clipId || '', nickname: base.nickname || '', profileImageUrl: base.profileImageUrl || '', description: base.description || '', i_follow: iFollow, follows_me: followsMe, relation: relation }); } const workbook = window.XLSX.utils.book_new(); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followers), 'Followers'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(followings), 'Followings'); window.XLSX.utils.book_append_sheet(workbook, window.XLSX.utils.json_to_sheet(merged), 'Merged'); const workbookOutput = window.XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }); const blob = new Blob([workbookOutput], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); const now = new Date(); const pad = n => String(n).padStart(2, '0'); link.download = `clip-follow-map-${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}.xlsx`; document.body.appendChild(link); link.click(); URL.revokeObjectURL(link.href); link.remove(); this.updateStatus(`✅ 완료! Followers ${followers.length}, Followings ${followings.length}`); setTimeout(() => this.cleanup(), 2500); } cleanup() { if (this.ui) { this.ui.remove(); this.ui = null; } window.__followBot = false; } } class UnfollowCleaner { constructor() { this.ui = null; this.profileId = null; this.followingsData = []; this.followersData = []; this.followersMap = new Map(); this.onlyMeFollowList = []; this.processedCount = 0; this.cancelled = false; this.checkCount = 0; this.unfollowCount = 0; window.__unfollowMode = true; } async start() { if (!confirm('내 클립 계정 화면이 맞나요?')) { this.cleanup(); return; } this.createUI(); try { this.profileId = this.extractProfileId(); if (!this.profileId) { this.profileId = prompt('profileId를 입력해주세요:', ''); if (!this.profileId) { this.cleanup(); return; } } await this.ensureFollowListPage(); await this.collectAllFollowersData(); await this.navigateToFollowings(); await this.executeUnfollowOnFollowingPage(); } catch (error) { console.error('Unfollow cleanup error:', error); this.updateStatus('⚠️ 오류: ' + error.message); } } createUI() { const ui = document.createElement('div'); ui.style.cssText = ` position: fixed; right: 12px; bottom: 12px; z-index: 2147483647; background: rgba(14,14,16,.88); backdrop-filter: blur(6px); color: #fff; padding: 12px 14px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,.35); font: 12px/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial; min-width: 250px; text-align: center; `; ui.innerHTML = ` <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,.16); padding-bottom: 6px; font-size: 12px; font-weight: 600; text-align: center;"> 블라이, '상위노출' 분석 서비스 : <a href="https://blai.co.kr?invite=늑대왕" target="_blank" rel="noopener" style="color: #9ccfff; text-decoration: underline;">바로가기</a> </div> <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px;"> <b style="font-size: 13px;">Clip Follow Surfer</b> <span id="badge" style="padding: 2px 8px; border-radius: 999px; background: #f59e0b; color: #fff; font-weight: 700; font-size: 10px; letter-spacing: .25px;">언팔중</span> </div> <div id="stats" style="opacity: .95; font-size: 11px; line-height: 1.4; margin-bottom: 8px;"> 관계확인: <b id="checkCount">0</b> | 언팔로우: <b id="unfollowCount">0</b> </div> <div id="statusText" style="opacity: .8; font-size: 10px; color: #9ccfff; margin: 4px 0; min-height: 15px; display: flex; align-items: center; justify-content: center;">🗑️ 뒷삭 관리 시작...</div> <div id="btnRow" style="margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;"> <button id="closeBtn" style="flex: 1 1 auto; width: 100%; padding: 6px 10px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; box-shadow: 0 1px 0 rgba(255,255,255,.07) inset, 0 2px 10px rgba(0,0,0,.25); transition: transform .08s ease, filter .15s ease, opacity .2s ease; background: #b91c1c; color: #fff;">Close</button> </div> <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,.16); padding-top: 8px; font-size: 10px; opacity: .7;"> 버전 : ${VERSION} </div> `; document.body.appendChild(ui); this.ui = ui; const closeBtn = ui.querySelector('#closeBtn'); closeBtn.onclick = () => { this.cancelled = true; this.updateStatus('❌ 사용자가 중단했습니다'); setTimeout(() => this.cleanup(), 1000); }; this.addHoverEffects(closeBtn); } addHoverEffects(button) { button.onmouseenter = () => button.style.filter = 'brightness(1.06)'; button.onmouseleave = () => button.style.filter = 'none'; button.onmousedown = () => button.style.transform = 'scale(0.98)'; button.onmouseup = () => button.style.transform = 'scale(1)'; } updateStatus(message) { if (this.ui) { const statusText = this.ui.querySelector('#statusText'); if (statusText) { statusText.textContent = message; } else { this.ui.textContent = message; } } } extractProfileId() { try { const html = document.documentElement.innerHTML; const matches = [...html.matchAll(/"profileId":"([A-Za-z0-9_\-]+)"/g)].map(x => x[1]); if (matches.length) { const frequency = matches.reduce((acc, val) => (acc[val] = (acc[val] || 0) + 1, acc), {}); return Object.entries(frequency).sort((a, b) => b[1] - a[1])[0][0]; } } catch (error) { console.warn('Profile ID extraction error:', error); } return null; } async ensureFollowListPage() { const currentUrl = location.href; const isProfilePage = /\/@[^\/]+$/.test(currentUrl) && !currentUrl.includes('/follow'); if (isProfilePage) { this.updateStatus('📱 프로필에서 팔로우 목록으로 이동 중...'); const followerTab = Utils.queryAll('a, button, [role="button"]').find(element => { const text = Utils.normalizeText(element); return /팔로워/i.test(text); }); if (followerTab) { followerTab.click(); await Utils.sleep(2000); this.updateStatus('✅ 팔로우 목록으로 이동 완료'); } else { const followUrl = currentUrl + '/follow'; location.href = followUrl; await Utils.sleep(2000); } } } async collectFollowData() { this.updateStatus('📥 팔로워 데이터 수집 중...'); this.followersData = await this.fetchFollowData('followers'); } async fetchFollowData(type) { const endpoint = '/api/graphql'; const queries = { followers: `query Q($after:String,$first:Int,$input:FollowersInput!){followers(input:$input,after:$after,first:$first){edges{node{profileId clipId nickname profileImageUrl description follow id}}pageInfo{hasNextPage endCursor totalCount}}}`, followings: `query Q($after:String,$first:Int,$input:FollowingsInput!){followings(input:$input,after:$after,first:$first){edges{node{profileId clipId nickname profileImageUrl description follow id}}pageInfo{hasNextPage endCursor totalCount}}}` }; const query = queries[type]; const key = type; let cursor = null; const results = []; for (let i = 0; i < 9999; i++) { this.updateStatus(`📥 ${type} ${results.length}개 수집 중...`); const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 50, input: { profileId: this.profileId } } }) }); const data = await response.json(); const root = data.data[key]; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) { continue; } results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; await Utils.sleep(350 + Math.random() * 250); } return results; } async navigateToFollowings() { this.updateStatus('📱 팔로잉 목록으로 이동 중...'); const followingTab = Utils.queryAll('a[role="tab"]').find(tab => { const span = tab.querySelector('span.follow_name__oJvt8'); return span && /팔로잉/.test(span.textContent); }); if (followingTab) { followingTab.click(); await Utils.sleep(2000); let attempts = 0; while (attempts < 5) { const isFollowingActive = Utils.queryAll('a[role="tab"][aria-selected="true"]').some(tab => { const span = tab.querySelector('span.follow_name__oJvt8'); return span && /팔로잉/.test(span.textContent); }); if (isFollowingActive) { this.updateStatus('✅ 팔로잉 목록으로 이동 완료'); return; } attempts++; this.updateStatus(`📱 팔로잉 탭 활성화 확인 중... (${attempts}/5)`); await Utils.sleep(1000); } this.updateStatus('❌ 팔로잉 탭 활성화 실패 - 수동으로 팔로잉 탭을 클릭해주세요'); } else { const currentUrl = location.href; const baseUrl = currentUrl.split('?')[0].split('#')[0]; const followingUrl = baseUrl.includes('/following') ? currentUrl : baseUrl + '/following'; if (location.href !== followingUrl) { location.href = followingUrl; await Utils.sleep(2000); } this.updateStatus('✅ 팔로잉 URL로 이동 완료'); } } async executeUnfollowOnFollowingPage() { this.updateStatus('📱 팔로잉 페이지 로딩 대기 중...'); await Utils.sleep(1500); this.updateStatus('🔍 팔로잉 목록에서 나만 팔로우한 계정 탐색 중...'); let totalUnfollowed = 0; let consecutiveNoButton = 0; const maxConsecutiveNoButton = 15; let consecutiveNoAction = 0; const maxConsecutiveNoAction = 10; let processedButtons = new Set(); let checkedAccounts = new Set(); let memoryCleanupCounter = 0; let lastScrollHeight = 0; let scrollAttempts = 0; let stableHeightCount = 0; let noNewContentCount = 0; let lastButtonCount = 0; const maxScrollAttempts = 30; const maxStableHeight = 8; const maxNoNewContent = 5; while (consecutiveNoButton < maxConsecutiveNoButton && !this.cancelled) { const currentFollowingButtons = this.findFollowingButtonsOnFollowingPage(); let actionTaken = false; const currentScrollHeight = document.documentElement.scrollHeight; const isPageFinished = await this.detectPageLoadingFinished( currentScrollHeight, lastScrollHeight, currentFollowingButtons.length, lastButtonCount, stableHeightCount, noNewContentCount ); if (isPageFinished.finished) { this.updateStatus(`✅ ${isPageFinished.reason} 탐색 완료.`); this.showCompletionMessage(isPageFinished.reason); return; } stableHeightCount = isPageFinished.stableHeightCount; noNewContentCount = isPageFinished.noNewContentCount; lastScrollHeight = currentScrollHeight; lastButtonCount = currentFollowingButtons.length; if (currentFollowingButtons.length === 0) { consecutiveNoButton++; this.updateStatus(`🔍 팔로잉 버튼 탐색 중... (${consecutiveNoButton}/${maxConsecutiveNoButton}) 높이안정: ${stableHeightCount}/${maxStableHeight}`); await this.triggerDynamicLoadingForUnfollow(); continue; } else { consecutiveNoButton = 0; } this.updateStatus(`🔍 현재 화면에서 ${currentFollowingButtons.length}개 팔로잉 버튼 발견`); for (const button of currentFollowingButtons) { if (this.cancelled) { this.updateStatus(`❌ 취소됨! ${totalUnfollowed}개 계정 언팔로우 완료`); setTimeout(() => this.cleanup(), 2000); return; } const buttonId = this.getButtonUniqueId(button); if (processedButtons.has(buttonId)) { continue; } const uniqueId = this.extractUniqueIdFromButton(button); if (uniqueId) { if (checkedAccounts.has(uniqueId)) { processedButtons.add(buttonId); continue; } this.updateStatus(`관계 확인: ${uniqueId}`); const followsMe = this.checkIfAccountFollowsMe(uniqueId); checkedAccounts.add(uniqueId); this.checkCount++; this.updateCounts(); if (!followsMe) { const isOnFollowingPage = this.verifyOnFollowingPage(); if (!isOnFollowingPage) { this.updateStatus('❌ 팔로잉 화면이 아닙니다. 수동으로 팔로잉 탭을 클릭해주세요.'); break; } const accountName = this.extractAccountNameFromButton(button); this.updateStatus(`언팔로우: ${accountName}`); await this.safeButtonClick(button); Utils.simulateMouseEvents(button); button.click(); this.unfollowCount++; this.updateCounts(); totalUnfollowed++; actionTaken = true; processedButtons.add(buttonId); this.updateStatus(`언팔로우 완료: ${accountName}`); await Utils.sleep(80 + Math.random() * 40); } else { this.updateStatus(`맞팔 계정: ${uniqueId} (유지)`); processedButtons.add(buttonId); } } } if (actionTaken) { consecutiveNoAction = 0; memoryCleanupCounter++; if (memoryCleanupCounter >= 50) { this.updateStatus('🧹 메모리 및 DOM 정리 중...'); await this.cleanupOldDOMElements(); const currentButtonIds = new Set(); const currentButtons = this.findFollowingButtonsOnFollowingPage(); currentButtons.forEach(btn => { currentButtonIds.add(this.getButtonUniqueId(btn)); }); const oldSize = processedButtons.size; const newProcessedButtons = new Set(); for (const id of processedButtons) { if (currentButtonIds.has(id)) { newProcessedButtons.add(id); } } processedButtons = newProcessedButtons; const currentUniqueIds = new Set(); currentButtons.forEach(btn => { const uniqueId = this.extractUniqueIdFromButton(btn); if (uniqueId) currentUniqueIds.add(uniqueId); }); const oldCheckedSize = checkedAccounts.size; const newCheckedAccounts = new Set(); for (const id of checkedAccounts) { if (currentUniqueIds.has(id)) { newCheckedAccounts.add(id); } } checkedAccounts = newCheckedAccounts; const removed = oldSize - processedButtons.size; const removedChecked = oldCheckedSize - checkedAccounts.size; this.updateStatus(`🧹 정리완료: Set ${removed}개, 관계확인 ${removedChecked}개, DOM 정리됨`); memoryCleanupCounter = 0; await Utils.sleep(200); if (this.unfollowCount > 0 && this.unfollowCount % 500 === 0) { this.updateStatus('🔄 페이지 리셋 중... (봇 탐지 회피)'); const currentY = window.scrollY; window.scrollTo(0, Math.max(0, currentY * 0.3)); await Utils.sleep(1000); this.updateStatus('🔄 페이지 리셋 완료, 탐색 재개'); } } window.scrollBy(0, window.innerHeight * 1.5); await Utils.sleep(500); } else { consecutiveNoAction++; const beforeScrollHeight = document.documentElement.scrollHeight; this.updateStatus(`📜 더 많은 팔로잉 목록 로드 중...\n(${consecutiveNoAction}/${maxConsecutiveNoAction})`); await this.triggerDynamicLoadingForUnfollow(); const afterScrollHeight = document.documentElement.scrollHeight; if (beforeScrollHeight === afterScrollHeight) { await Utils.sleep(500); } } } if (!this.cancelled) { this.updateStatus(`✅ 완료! 총 ${totalUnfollowed}개 계정 언팔로우 완료`); this.showCompletionMessage(`총 ${totalUnfollowed}개 계정 언팔로우 완료`); } } checkIfAccountFollowsMe(accountId) { return this.followersMap.has(accountId); } extractUniqueIdFromButton(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) return decodeURIComponent(match[1]); } const txtAreaElement = parent.querySelector('[class*="UIProfileListItem_txt_area"]'); if (txtAreaElement) { const uniqueId = txtAreaElement.textContent?.trim(); if (uniqueId && uniqueId.length > 0 && !uniqueId.includes('팔로우')) { return uniqueId; } } } return null; } async safeButtonClick(button) { Utils.scrollToCenter(button); await Utils.sleep(200); let attempts = 0; const maxAttempts = 5; while (attempts < maxAttempts) { if (button.isConnected && !button.disabled && button.offsetParent !== null && button.getAttribute('aria-pressed') === 'true') { await Utils.sleep(100); return; } attempts++; this.updateStatus(`버튼 안정화 대기 중... (${attempts}/${maxAttempts})`); await Utils.sleep(200); if (attempts > 2) { Utils.scrollToCenter(button); await Utils.sleep(300); } } this.updateStatus(`⚠️ 버튼 상태 불안정하지만 클릭 시도`); } verifyOnFollowingPage() { const followingTabActive = Utils.queryAll('a[role="tab"][aria-selected="true"]').some(tab => { const span = tab.querySelector('span.follow_name__oJvt8'); return span && /팔로잉/.test(span.textContent); }); const visibleFollowContentAreas = Utils.queryAll('.follow_content_area__rMgiS > div').filter(div => { const style = window.getComputedStyle(div); return style.display === 'block'; }); return followingTabActive && visibleFollowContentAreas.length > 0; } findFollowingButtons() { return Utils.queryAll('a.UIProfileListItem_btn_follow__FRmTC').filter(button => { const text = Utils.normalizeText(button); return /팔로잉|Following/.test(text) && button.getAttribute('aria-pressed') === 'true'; }); } findFollowingButtonsOnFollowingPage() { const followingTabActive = Utils.queryAll('a[role="tab"][aria-selected="true"]').some(tab => { const span = tab.querySelector('span.follow_name__oJvt8'); return span && /팔로잉/.test(span.textContent); }); if (!followingTabActive) { return []; } const visibleFollowContentAreas = Utils.queryAll('.follow_content_area__rMgiS > div').filter(div => { const style = window.getComputedStyle(div); return style.display === 'block'; }); if (visibleFollowContentAreas.length === 0) { return []; } const followingContentArea = visibleFollowContentAreas[0]; const buttons = Utils.queryAll('a.UIProfileListItem_btn_follow__FRmTC', followingContentArea).filter(button => { const text = Utils.normalizeText(button); const isFollowingButton = /팔로잉|Following/.test(text) && button.getAttribute('aria-pressed') === 'true'; const isInFollowingList = button.closest('li[class*="UIProfileListItem"]'); const isConnected = button.isConnected; return isFollowingButton && isInFollowingList && isConnected; }); return buttons; } getButtonUniqueId(button) { const rect = button.getBoundingClientRect(); const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); let uniqueText = ''; if (parent) { const textElements = parent.querySelectorAll('[class*="txt_area"], [class*="tit_area"]'); textElements.forEach(el => { uniqueText += el.textContent?.trim() || ''; }); } return `${Math.round(rect.top)}_${Math.round(rect.left)}_${uniqueText.slice(0, 20)}`; } extractAccountIdFromButton(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return accountId.replace(/^@/, ''); } } const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) { return decodeURIComponent(match[1]); } } } return null; } extractAccountNameFromButton(button) { const parent = button.closest('li[class*="UIProfileListItem"]') || button.closest('[class*="UIRecommendCreatorCarouselType_list_item"]') || button.closest('div[class*="list_item"]'); if (parent) { const idElement = parent.querySelector('[class*="UIProfileListItem_txt_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (idElement) { const accountId = idElement.textContent?.trim(); if (accountId && accountId.length > 0 && !accountId.includes('팔로우')) { return '@' + accountId; } } const nameElement = parent.querySelector('[class*="UIProfileListItem_tit_area"],[class*="UIRecommendCreatorCarouselType_tit_area"],[class*="tit_area"]'); if (nameElement) { const accountName = nameElement.textContent?.trim(); if (accountName && accountName.length > 0 && !accountName.includes('팔로우')) { return accountName.slice(0, 15); } } const linkElement = parent.querySelector('a[href*="/@"]'); if (linkElement) { const href = linkElement.getAttribute('href') || ''; const match = href.match(/\/@([^/?#]+)/); if (match) { return '@' + decodeURIComponent(match[1]); } } } return '알수없음'; } updateCounts() { if (this.ui) { const checkCountElement = this.ui.querySelector('#checkCount'); const unfollowCountElement = this.ui.querySelector('#unfollowCount'); if (checkCountElement) { checkCountElement.textContent = this.checkCount; } if (unfollowCountElement) { unfollowCountElement.textContent = this.unfollowCount; } } } showCompletionMessage(reason) { if (this.ui) { const badge = this.ui.querySelector('#badge'); const closeBtn = this.ui.querySelector('#closeBtn'); if (badge) { badge.textContent = '완료'; badge.style.background = '#10b981'; } if (closeBtn) { closeBtn.style.display = 'inline-block'; closeBtn.style.width = '100%'; closeBtn.textContent = 'Close'; } } this.updateStatus(`🎉 ${reason} 필요 시 반복해서 작업을 수행하세요.`); } async cleanupOldDOMElements() { try { const currentScrollY = window.scrollY; const windowHeight = window.innerHeight; const cleanupThreshold = windowHeight * 3; const followingItems = Utils.queryAll('li[class*="UIProfileListItem"]'); let removedCount = 0; for (const item of followingItems) { const rect = item.getBoundingClientRect(); const itemTopY = currentScrollY + rect.top; if (itemTopY < (currentScrollY - cleanupThreshold)) { try { item.remove(); removedCount++; } catch (e) { } } } if (window.gc && typeof window.gc === 'function') { window.gc(); } console.log(`DOM 정리 완료: ${removedCount}개 요소 제거`); return removedCount; } catch (error) { console.warn('DOM 정리 중 오류:', error); return 0; } } async detectPageLoadingFinished(currentHeight, lastHeight, currentButtonCount, lastButtonCount, stableHeightCount, noNewContentCount) { let newStableHeightCount = (currentHeight === lastHeight) ? stableHeightCount + 1 : 0; let newNoNewContentCount = (currentButtonCount === lastButtonCount) ? noNewContentCount + 1 : 0; const isAtBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - 100); const hasMoreButton = Utils.queryAll('button, div').some(el => { const text = el.textContent || ''; return /더.*보기|더.*로드|loading|로딩/i.test(text); }); if (newStableHeightCount >= 8 && newNoNewContentCount >= 5) { this.updateStatus('📄 페이지 끝 확인 중... 잠시만 기다려주세요.'); await Utils.sleep(3000); const finalHeight = document.documentElement.scrollHeight; const finalButtons = this.findFollowingButtonsOnFollowingPage(); if (finalHeight === currentHeight && finalButtons.length === currentButtonCount) { return { finished: true, reason: "모든 동적 로딩 완료", stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } } if (isAtBottom && newStableHeightCount >= 5) { this.updateStatus('📄 페이지 하단 도달 확인 중...'); await Utils.sleep(2000); const finalHeight = document.documentElement.scrollHeight; if (finalHeight === currentHeight) { return { finished: true, reason: "스크롤 종료.", stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } } return { finished: false, stableHeightCount: newStableHeightCount, noNewContentCount: newNoNewContentCount }; } async triggerDynamicLoadingForUnfollow() { this.updateStatus('🌊 동적 로딩 중...'); window.scrollBy(0, window.innerHeight * 1.5); await Utils.sleep(200); window.scrollBy(0, -window.innerHeight * 0.3); await Utils.sleep(150); window.scrollBy(0, window.innerHeight * 0.8); await Utils.sleep(300); const randomMove = (Math.random() - 0.5) * window.innerHeight * 0.2; window.scrollBy(0, randomMove); await Utils.sleep(150); this.updateStatus('✅ 동적 로딩 완료'); return true; } async collectAllFollowersData() { this.updateStatus('📥 전체 팔로워 데이터 수집 중... (버튼 상태 무관)'); const endpoint = '/api/graphql'; const query = ` query Q($after:String,$first:Int,$input:FollowersInput!) { followers(input:$input,after:$after,first:$first) { edges { node { profileId clipId nickname profileImageUrl description follow id } } pageInfo { hasNextPage endCursor totalCount } } } `; let cursor = null; const results = []; for (let i = 0; i < 9999; i++) { if (this.cancelled) return; this.updateStatus(`📥 팔로워 ${results.length}개 수집 중...`); const response = await fetch(endpoint, { method: 'POST', headers: { 'content-type': 'application/json', 'accept': 'application/json' }, body: JSON.stringify({ query: query, variables: { after: cursor, first: 50, input: { profileId: this.profileId } } }) }); const data = await response.json(); const root = data.data.followers; const edges = root.edges || []; for (const edge of edges) { const node = edge.node || {}; const id = node.profileId || node.clipId; if (!id || results.some(item => (item.profileId || item.clipId) === id)) continue; results.push({ profileId: node.profileId || '', clipId: node.clipId || '', nickname: node.nickname || '', profileImageUrl: node.profileImageUrl || '', description: (node.description || '').replace(/\r?\n/g, ' ').trim(), follow: node.follow === true }); } if (!root.pageInfo.hasNextPage) break; cursor = root.pageInfo.endCursor; await Utils.sleep(350 + Math.random() * 250); } this.followersMap = new Map(); for (const follower of results) { if (follower.clipId) { this.followersMap.set(follower.clipId, follower); } else if (follower.profileId) { this.followersMap.set(follower.profileId, follower); } } this.updateStatus(`✅ 전체 팔로워 ${results.length}명 수집 완료 (버튼 상태 무관 전체 포함)`); await Utils.sleep(1000); } cleanup() { if (this.ui) { this.ui.remove(); this.ui = null; } window.__unfollowMode = false; window.__followBot = false; } } class ClipFollowSurfer { constructor() { this.state = new BotState(); this.ui = new BotUI(this.state); this.detector = new PageDetector(this.state); this.actions = new BotActions(this.state, this.ui, this.detector); this.scroller = new AutoScroller(this.state, this.actions); this.mainLoop = null; this.uiUpdater = null; this.mutationObserver = null; this.justNavigated = false; this.initialize(); } initialize() { this.setupMutationObserver(); this.startMainLoop(); this.startUIUpdater(); this.scroller.start(); const originalDestroy = this.ui.destroy.bind(this.ui); this.ui.destroy = () => { this.cleanup(); originalDestroy(); }; } setupMutationObserver() { this.mutationObserver = new MutationObserver(() => { if (this.justNavigated) return; this.detector.detectPageType(); const profileElements = Utils.queryAll('[class*="UIProfileInfo"],[class*="UIProfileHeader"]'); if (profileElements.length > 0) { setTimeout(() => this.detector.gotoFollowerTab(), 500); } }); this.mutationObserver.observe(document.documentElement, { childList: true, subtree: true }); } startMainLoop() { this.mainLoop = setInterval(async () => { await this.executeMainLoop(); }, 1000); } async executeMainLoop() { if (!this.state.run) return; const pageType = this.detector.detectPageType(); if (pageType !== 'profile') { const clickedCount = await this.actions.clickAllFollows(); if (clickedCount > 0) { await Utils.sleep(1500); } } if (this.state.totalSurf >= 100) { this.ui.setPausedState(UIConstants.LABELS.done); return; } if (!window.__unfollowMode && this.shouldSurf(pageType)) { this.ui.updateAction('파도타기 시작...'); const success = await this.actions.surfNextProfile(); if (success) { this.justNavigated = true; setTimeout(() => { this.justNavigated = false; }, 2000); this.state.empty = 0; this.state.dynamicLoads = 0; this.state.clickedButtons.clear(); this.state.stableScrollCount = 0; } } } shouldSurf(pageType) { return this.state.empty >= 5 && pageType === 'list' && !this.state.justSurfed; } startUIUpdater() { this.uiUpdater = setInterval(() => { this.ui.updateCounts(); }, 1000); } cleanup() { try { if (this.mainLoop) clearInterval(this.mainLoop); if (this.uiUpdater) clearInterval(this.uiUpdater); if (this.mutationObserver) this.mutationObserver.disconnect(); this.scroller.stop(); } catch (error) { console.warn('Cleanup error:', error); } } } class App { static start() { const menu = new StartMenu(); menu.show((option) => { switch (option) { case 'followSurf': new ClipFollowSurfer(); break; case 'excelExport': new ExcelExporter().start(); break; case 'unfollowCleanup': new UnfollowCleaner().start(); break; case 'cancel': window.__followBot = false; break; } }); } } App.start(); })();
